# 사견

알고리즘을 공부 안하면 SI 직행입니다. 단순코드 복붙합니다. 개발자로서 사고력을 함양할 수 없습니다.

메모리 효율적이거나 문제를 잘 해결하기 위해서는 자료구조와 알고리즘을 짝으로 알아야 합니다.

# 알고리즘

> 어떤 문제의 해결을 위하여, 입력된 자료를 토대로 하여 원하는 출력을 유도하여 내는 규칙의 집합. 여러 단계의 유한 집합으로 구성되는데, 각 단계는 하나 또는 그 이상의 연산을 필요로 한다.
>
> \- 표준국어대사전

간단하게는 문제를 해결하기 위한 유한한 절차의 합입니다.

알고리즘은 상황에 따라 효율성을 선택하는 기준이 다릅니다. 공간복잡성이 필요할 때와 시간복잡성이 필요할 때가 각각다릅니다.

자료구조와 알고르즘을 배우면 성능을 기준으로 좋은 코드와 나쁜 코드를 판단할 수 있습니다.

참고로 현업에서 일할 때는 이미 좋은 알고리즘이 다 구현되어 있습니다. 읽고 변형해서 사용하면 됩니다. 하지만 구현능력으로 개발자의 소양을 기르도록 합니다.

![Algorithm Growth](../img/1_iEbD3x2S5KOiEI6ZOltp9w.png)
Algorithm Growth입니다. 알고리즘의 시간복잡성을 나타내는 Big-O 표기법 그래프입니다.

[Algorithm Analysis & Time Complexity Simplified - 미디엄 아티클 클릭하지마세요. 제한 걸려있습니다.](https://randerson112358.medium.com/algorithm-analysis-time-complexity-simplified-cd39a81fec71)

알고리즘 분석은 중요합니다. Algorithm analysis is an important part of a broader computational complexity theory, which provides theoretical estimates for the resources (space and time)needed by any algorithm which solves a given computational problem. <-- 나머지는 미래의 저가 번역해줄 것입니다.

보통 시간복잡성이라고 하면 컴퓨터가 작업을 수행한 횟수를 말합니다.

Big-O (O), Big Omega (Ω) and Big Theta (Θ)가 각각 존재합니다.

Big-O (O)는 최악의 경우 Big Omega (Ω)는 최고의 경우 Big Theta (Θ)는 최고와 최악의 평균입니다.

보통은 최악의 경우를 대응해줍니다. 하지만 현실에서 모든 최악의 경우를 대응하지는 않습니다. 대응할 때마다 발생할 수익성을 판단하고 대응합니다.

알고리즘 분석으로 모든 강의가 회귀할 것입니다. 그래서 알고리즘 분석을 대충하지 말도록 합니다. 소프트웨어 엔지니어의 수학적 소양은 기본 중 기본입니다.

사람들이 자주 착각하는 것이 있는데 자료구조와 알고리즘은 서로 독립적이지 않습니다. 서로 짝을 이룹니다.

목차

1. [과제 구현 능력](#과제-구현-능력)
2. [배열(Array)과 연결된 리스트(Linked List)](#배열과-연결된-리스트)
3. [정렬(Sort), 스택(Stack), 큐(Queue), 해쉬(Hash)](#정렬sort-스택stack-큐queue-해쉬hash)
4. [힙(heap), BFS, DFS, Dynamic Programming](#힙heap-bfs-dfs-dynamic-programming)
5. [종합 알고리즘 문제 풀이](#종합-알고리즘-문제-풀이)

## 과제 구현 능력

### 최대값 찾기

```py
def find_max_num(array):
    # 이 부분을 채워보세요!
    return 1


print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))
```

간단한 문제입니다. 내장함수를 사용하는 방법과 사용하지 않는 2가지 모두 구현하도록 합니다.

pep는 파이썬 스타일가이드입니다.

지정변수, 초깃값 설정 전략을 활용할 수 있습니다.

### 최빈값 찾기

`isalpha()` 문자열 메서드를 사용해서 alphabet a ~ z 대소문자 모두 해당하는 알파벳인지 파악합니다. 띄어쓰기, 특수문자, 숫자는 `False`를 반환합니다.

`ord()` 내장함수는 아스키 (ASCII) 코드의 10진값을 조회할 수 있습니다.

```py
def find_max_occurred_alphabet(string):
    # 이 부분을 채워보세요!
    return "a"

print("정답 = a 현재 풀이 값 =", find_max_occurred_alphabet("Hello my name is sparta"))
print("정답 = a 현재 풀이 값 =", find_max_occurred_alphabet("Sparta coding club"))
print("정답 = s 현재 풀이 값 =", find_max_occurred_alphabet("best of best sparta"))
```

### 시간복잡도

시간복잡도는 입력자료량과 처리시간 사이 상관관계입니다. 시간복잡도가 낮을수록 성능이 좋은 프로그램이라고 할 수 있습니다.

시간복잡도를 계산하는 방법입니다. <strong> 1줄을 연산이라고 생각하면 간단합니다. </strong> 실제로는 더 복잡할 수 있습니다. 하지만 1줄 중에 반복문은 계수로 표현합니다.

자료입력은 많은 경우 함수(메서드)인자를 주로 의미합니다.

O(N) 방식으로 표현하는 이유는 시간복잡성은 가변적인 입력자료를 받기 때문에 추상화한 것입니다.

중첩 반복문을 사용해서 문제를 해결할 수 있지만 사용하지 말아야 할 이유입니다.

```py
for num in array:              # array 의 길이만큼 아래 연산이 실행
    for compare_num in array:  # array 의 길이만큼 아래 연산이 실행
        if num < compare_num:  # 비교 연산 1번 실행
            break
    else:
        return num
```

$$
N_{num} \times N_{compare\ num}
$$

즉 하나의 $N$개의 배열 원소를 넣으면 $N^{2}$번의 연산을 합니다. $O(N^{2})$ 시간복잡성을 갖습니다. 극도로 비효율적입니다.

```py
for num in array:      # array 의 길이만큼 아래 연산이 실행
    if num > max_num:  # 비교 연산 1번 실행
        max_num = num  # 대입 연산 1번 실행
```

반면 단순 반복문은 지금 코드에서는 $O(2N)$ 시간복잡성을 갖습니다. 하지만 보통 상수는 무시합니다. 그리고 가장 높은차의 계수(이 예시의 경우 $2N$ 중 2)도 무시합니다.

시간복잡성에서 집중할 것은 차수입니다.

대부분의 경우 지불하는 비용은 공간복잡도를 지불하고 시간복잡도 성능을 개선하는데 사용합니다.

### 공간복잡도

공간복잡도는 입력자료량과 할당하는 메모리량 사이 상관관계입니다. 대부분의 경우 시간복자도가 더 중요합니다. 하지만 공간복잡도 문제도 많이 출제합니다. 시간복잡도를 먼저 공부하고 대비한 다음에 대비하기를 권장합니다.

```py
alphabet_array = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"]
# -> 26 개의 공간을 사용합니다
max_occurrence = 0 # 1개의 공간을 사용합니다
max_alphabet = alphabet_array[0]   # 1개의 공간을 사용합니다.

for alphabet in alphabet_array:
    occurrence = 0  # 1개의 공간을 사용합니다
```

위 코드는 모두 상수만큼의 공간복잡도를 갖습니다.

### 점근 표기법(asymptotic notation)

알고리즘의 성능을 수학적으로 표기하는 방법입니다. 알고리즘의 “효율성”을 평가하는 방법입니다. 점근 표기법(asymptotic notation)은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법이다.

점근 표기법은 함수의 증가양상을 간단하게 비교로 표기한 해석학과 수론의 방법론입니다.

#### 배열에서 특정 요소 찾기

```py
# Q. 다음과 같은 숫자로 이루어진 배열이 있을 때, 이 배열 내에 특정 숫자가 존재한다면 True, 존재하지 않다면 False 를 반환하시오.
def is_number_exist(number, array):
    # 이 부분을 채워보세요!
    return True


result = is_number_exist
print("정답 = True 현재 풀이 값 =", result(3,[3,5,6,1,2,4]))
print("정답 = Flase 현재 풀이 값 =", result(7,[6,6,6]))
print("정답 = True 현재 풀이 값 =", result(2,[6,9,2,7,1888]))
```

이런 알고리즘을 풀기 위해서 하는 것은 선형탐색입니다. 순서대로 값을 찾습니다. 순서대로 순회해야 합니다. 또 최악의 경우는 입력한 자료량만큼 순회해야 합니다. 이럴때는 $O(N)$에 해당합니다.

알고리즘은 입력값의 분포에 따라서 성능이 다를 수 있습니다.

알고리즘은 최악의 경우가 대부분입니다. 그래서 최악의 경우를 대응하기 위해서 $Big-O$ 표기법을 사용합니다.

### 곱하기 or 더하기

```py
# Q. 다음과 같이 0 혹은 양의 정수로만 이루어진 배열이 있을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 '✕' 혹은 '+' 연산자를 넣어 결과적으로 가장 큰 수를 구하는 프로그램을 작성하시오.

# 단, '+' 보다 '✕' 를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서 순서대로 이루어진다.
def find_max_plus_or_multiply(array):
    # 이 부분을 채워보세요!
    return 1


result = find_max_plus_or_multiply
print("정답 = 728 현재 풀이 값 =", result([0,3,5,6,1,2,4]))
print("정답 = 8820 현재 풀이 값 =", result([3,2,1,5,9,7,4]))
print("정답 = 270 현재 풀이 값 =", result([1,1,1,3,3,2,5]))
# 풀이의 시간복잡도는 무엇인가요?
```

### 반복되지 않는 문자

```py
# Q. 다음과 같이 영어로 되어 있는 문자열이 있을 때, 이 문자열에서 반복되지 않는 첫번째 문자를 반환하시오. 만약 그런 문자가 없다면 _ 를 반환하시오.
input = "abadabac"

def find_not_repeating_first_character(string):
    # 이 부분을 채워보세요!
    return "_"


result = find_not_repeating_first_character
print("정답 = d 현재 풀이 값 =", result("abadabac"))
print("정답 = c 현재 풀이 값 =", result("aabbcddd"))
print("정답 =_ 현재 풀이 값 =", result("aaaaaaaa"))
# 풀이의 시간복잡도는 무엇인가요?
```

반복의 기준이 홀수번 등장한 문자입니다.

### 숙제

#### 소수 나열하기

```py
# Q. 정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오.
# 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다.

input = 20  # output = [2, 3, 5, 7, 11, 13, 17, 19]

def find_prime_list_under_number(number):
    # 이 부분을 채워보세요!
    return []


result = find_prime_list_under_number(input)
print(result)
# 시간복잡성을 묘사하십시오.
```

```py
# Q. 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자열에 있는 모든 숫자를 전부 같게 만들려고 한다. 할 수 있는 행동은 문자열에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

# 예를 들어 S=0001100 일 때,

# 전체를 뒤집으면 1110011이 된다.
# 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
# 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

# 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.

input = "011110"

def find_count_to_turn_out_to_all_zero_or_all_one(string):
    # 이 부분을 채워보세요!
    return 1

result = find_count_to_turn_out_to_all_zero_or_all_one(input)
print(result)
# 시간복잡성을 묘사하십시오.
```

```py
# Q.
# 1. 입력으로 소문자의 알파벳 순으로 정렬된 문자열이 입력됩니다.
# 2. 각 알파벳은 중복이 가능합니다.
# 3. 중간에 없는 알파벳이 있을 수도 있습니다.

# 입,출력 예시와 같이 입력 문자열에 나타나는 각 알파벳의 종류,갯수를 요약하여 나타내시오.

def summarize_string(input_str):
    # 이 부분을 채워보세요!

input_str = "acccdeee"

print(summarize_string(input_str))
# 시간복잡성을 묘사하십시오.
```

## 배열(Array)과 연결된 리스트(Linked List)

자료구조마다 효율적인 알고리즘이 각각 다릅니다. 프로그램에서 문제를 해결하는 또 다른 도구입니다.

연결된 리스트는 값과 다음 노드를 지정하는 방식입니다.

### 배열

배열은 크기가 정해진 연속된 데이터의 공간(메모리)입니다. 한번 정해지면 바꿀 수 없습니다. 배열은 원소에 즉시 접근(O(1) 시간복잡성)할 수 있습니다. 배열은 원소를 중간에 삽입하면 모든 원소를 움직여야 합니다. O(N) 시간복잡성을 갖습니다. 배열은 새로운 원소를 추가하기 위해서는 새로운 모두 옮겨주어야 하기 때문에 비효율적입니다.

현실에서는 요일별 먹어야 하는 알약통과 유사합니다. 오늘이 월요일이고 수요일에 어느약을 먹기 위에 중간에 넣으려면 다른 약들을 한칸식 옮겨 주어야 합니다. 상당히 비효율적입니다.

프로그래밍에서는 보통 변수는 한번에 하나씩 움직일 수 있습니다.

### 링크드 리스트

링크드 리스트 혹은 리스트는 혼용되는 용어입니다.

리스트는 크기가 정해지지 않은 데이터의 공간입니다. 크기가 자유롭게 키울 수 있습니다. 리스트는 특정 원소를 접근하려면 O(N) 시간복잡성을 갖습니다. 연결고리는 포인터 각 데이터 칸은 노드라고 합니다. 리스트는 중간에 삽입 삭제가 쉽습니다. 포인터만 변경하면 간단하게 할 수 있습니다. O(1) 시간복잡성으로 처리할 수 있습니다.

노드는 칸에 있는 데이터 다음칸이 무엇인지 알려주는 데이터 2가지를 가져야 합니다. 이럴 때는 클래스로 구현하는 것이 좋습니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

node = Node(3)
```

하나의 노드를 생성한 상태입니다. 그래서 포인터의 값은 `None`입니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

node1 = Node(3)
node2 = Node(12)
node1.next = node2

print(node1.data)       #  3
print(node1.next.data)  # 12
```

이렇게 하면 2개의 노드를 연결한 것입니다. `node1`은 머리고 `node2`는 꼬리에 해당합니다. `print`를 보면 `node1`을 통해서만 대입했습니다.

지금 만든 자료구조에서는 HeadNode만 저장하면 됩니다. 다음 노드들은 next 메서드로 접근하면 됩니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

class LinkedList:
    def __init__(self, data):
        self.head = Node(data)  # Head 역할을 할 Node를 할당합니다.

    def append(self, data):
        # 예외처리 Head가 없는 경우 append를 하면 Head로 할당해줍니다.
        if self.head is None:
            self.head = Node(data)
            return  # 메서드의 실행을 종료시킵니다.

        # Tail에 접근(선형탐색)
        cur = self.head
        while cur.next is not None:
            cur = cur.next

        # 추가
        cur.next = Node(data)

    def printAll(self):
        if self.head is None:
            print("empty")

        cur = self.head
        while cur is not None:
            print(cur.data)
            cur = cur.next

    # 인덱스 횟수만큼 이동하기 위해 for문을 사용합니다.
    def getNode(self, index):
        cur = self.head
        if index > 0:
            for idx in range(index):
                cur = cur.next
        return cur

    # 인덱스 번째 원소를 추가합니다.
    def addNode(self, index, value):
        newNode = Node(value)
        # head를 교체할 때
        if index == 0:
            newNode.next = self.head
            self.head = newNode
            return  #실행 종료

        prevNode = self.getNode(index - 1)  # [a] -> [b] -> [c] a랑 b사이 d를 추가할 때 b 이전 a를 선택합니다.
        nextNode = prevNode.next            # [b] 노드를 기록합니다.
        prevNode.next = newNode             # [a]의 다음 노드를 [d]를 바라보게 합니다. [a] -> [b] -> none  & [b] -> [c]
        newNode.next = nextNode             # [d]는 [b]를 바라보게 합니다. [a] -> [b] -> [b] -> [c]
        return  #실행 종료

    def deleteNode(self, index):
        # [a]를 삭제할 때
        if index == 0:
            self.head = self.getNode(index+1)
            return  #실행 종료

        # [d]를 삭제할 때
        if self.getNode(index).next == None:
            self.getNode(index-1).next = None
            return  #실행 종료

        # 유스케이스
        # [a] -> [b] -> [c] -> [d] 중에서 [c]를 삭제하기 위해 [b] 선택합니다.
        prevNode = self.getNode(index-1)
        # [a] -> [b] -> [d]로 포인터를 바꿉니다. [c]는 전후관계가 없어집니다. 메모리 누수가 있는지 모르겠습니다.
        prevNode.next = prevNode.next.next

# 5 -> 12 -> 8
linkedList = LinkedList(5)
linkedList.append(12)
linkedList.append(8)

linkedList.addNode(2, 3)
linkedList.deleteNode(3)
linkedList.printAll()
```

`LinkedList`입니다.

```py
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self, value):
        self.head = Node(value)

    def append(self, value):
        cur = self.head
        while cur.next is not None:
            cur = cur.next
        cur.next = Node(value)


def get_linked_list_sum(linked_list_1, linked_list_2):
    # 구현해보세요!
    return 1032


linked_list_1 = LinkedList(6)
linked_list_1.append(7)
linked_list_1.append(8)

linked_list_2 = LinkedList(3)
linked_list_2.append(5)
linked_list_2.append(4)

print(get_linked_list_sum(linked_list_1, linked_list_2))
```

`LinkedList`를 활용하는 문제입니다.

### Array vs Linked List

| 경우             | Array                                                                         | Linked List                                                  |
| ---------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------ |
| 특정 원소 조회   | O(1)                                                                          | O(N)                                                         |
| 중간에 삽입 삭제 | O(N)                                                                          | O(1)                                                         |
| 데이터 추가      | 데이터 추가 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받아야 한다 | 모든 공간이 다 찼어도 맨 뒤의 노드만 동적으로 추가하면 된다. |
| 정리             | 데이터에 접근하는 경우가 빈번하다면 Array를 사용하자                          | 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다. |

### 파이썬의 List

파이썬의 `list` 자료형은 배열로 구현되어 있습니다. 하지만 내부적으로 동적배열로 설계되어 있습니다. 파이썬은 Linked List, Array 모두 사용할 수 있습니다.

### 파이썬 클래스 다루기

클래스는 속성과 기능을 가진 객체를 총칭하는 개념입니다.

```py
class person:
    pass

jakeTheDog = person()
print(jakeTheDog)  # <__main__.person object at 0x1049c0a60>
```

`0x1049c0a60`은 메모리 주소입니다.

`person()`은 생성자 함수입니다. 함수가 실행되면 객체를 생성해줍니다. 그리고 `jakeTheDog` 식별자에 객체가 할당 되어 있습니다.

```py
class person:
    def __init__(self, name):  # 초기화 함수입니다. 생성자함수에 인자를 받아야 합니다.
        self.name = name  # 생성하면서 갖게 된 속성값입니다.
        print()

    def take(self):  # 메서드입니다. 메서드에는 첫번째 매개변수는 self여야 합니다.
        print('You stay away from my women! magic men')


jakeTheDog = person('jake')  # jakeTheDog 인스턴스를 생성한 것입니다.
print(jakeTheDog)  # <__main__.person object at 0x1049c0a60>
```

## 이진탐색과 선형탐색

소주게임 병뚜껑의 숫자를 맞추는 술게임 업다운이 있습니다. 대표적인 이진탐색 알고리즘을 실생활에 사용하는 경우입니다. 업다운은 알고리즘에서 어느것이 더 가까운지 알 수 있기 때문에 가운데를 찍고 맞췄는지 큰자 작은지 알아낼 수 있기 때문에 효율적입니다.

```py
finding_target = 14
finding_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]


def is_existing_target_number_binary(target, array):
    # 구현해보세요!
    return False


result = is_existing_target_number_binary(finding_target, finding_numbers)
print(result)
```

선형탐색은 $O(N)$ 시간복잡성을 갖습니다. 하지만 이진탐색은 $O(logN)$ 시간복잡성을 갖습니다.

이진탐색은 자료가 정렬되어 있어야 합니다.

## 재귀함수 Recursion

재귀함수는 자기자신을 반복적으로 호출하는 함수를 보고 재귀함수라고 합니다.

재귀함수를 활용하면 간략하고 효율적인 코드를 작성할 수 있습니다.

```py
def count_down(number):
    if number == 0: return
    print(number)          # number를 출력하고
    count_down(number - 1) # count_down 함수를 number - 1 인자를 주고 다시 호출한다!


count_down(60)
```

위코드는 재귀함수입니다. 재귀함수는 항상 베이스케이스 즉 종료조건부터 정의하고 다른 코드로 종료 조건을 유도하는 방식으로 작성합니다.

피보나치, 팩토리얼함수 등 구현하기 좋은 연습들이 존재합니다.

```py
def factorial(n):
    # 이 부분을 채워보세요!
    return 120

print(factorial(5))
```

베이스 케이스를 보고 특정숫자로 떨어지는 조건입니다.

회문은 일요일, 오디오, 토마토처럼 앞뒤로 똑같은 단어를 보고 하는 말입니다.

```py
input = "abcba"

def is_palindrome(string):
    return True

print(is_palindrome(input))
```

## 숙제

## 정렬(Sort), 스택(Stack), 큐(Queue), 해쉬(Hash)

## 힙(heap), BFS, DFS, Dynamic Programming

## 종합 알고리즘 문제 풀이

## 문제풀이 접근 방법

알고리즘 문제를 풀다보면, 문제 자체를 이해하기 힘들 때가 있습니다.

코드부터 작성하지 않습니다. 다른 케이스들의 규칙성을 파악하기 바랍니다.

배웠던 자료구조와 알고리즘 중 무엇으로 해결할 수 있는지 파악해봅니다.

문제의 특징을 하나식 글로 작성해봅니다.

수학적 성질 혹은 개념을 응용합니다. 평소 수학관련 교양을 쌓도록 합니다.

특정숫자의 특징 혹은 성질을 늘고민합니다.

문제를 독해할 때 무엇을 반환해야 하는지 유심히 읽어봅니다. 자료에 변형을 가한 그 자체인지 자료에 변형을 가하기 위한 횟수가 몇번진 등 간접적일 수 있습니다.

# 강창민 튜터 추가 특강

코딩테스트는 주로 지정해주지 않습니다. 지원자가 선택할 수 있는 경우가 많습니다.

알고리즘은 언어를 배울 때랑 또 격이 다릅니다. 알고리즘을 공부할 때 조금만 방향을 제공해주면 성장을 빠르게 할 수 있습니다.

알고리즘은 코딩테스트에 도전할 용기를 배우는 것도 중요합니다.

코딩테스트는 헬스랑 비슷합니다. 하기 싫지만 하면 엄청나게 성장할 수 있습니다. 알고리즘을 잘하는데 구현을 못하는 사람은 없습니다.

좋은 회사는 대부분의 경우 코딩테스트를 봅니다. 이력서는 30초 정도 판단합니다. 지인 추천은 검증되어 있어서 확정입니다.

코딩테스트는 좋은 회사가 정량적으로 무능한 지원자를 거를 수 있는 허들입니다.

어느 자료형을 사용해도 예를 들어 순서가 있고 없고 규칙을 암기하는 것은 의미가 없습니다. 왜 순서가 없는지 이 설계의도를 탐구해보기를 권장합니다.

코딩테스트에서 파이썬을 권장하는 이유는 가장 많이 사용하기 때문입니다. 자바는 거의 사용하지 않습니다. 자바스크립트는 의외로 맍습니다.

파이썬은 pypy3로 성능개선을 할 수 있습니다. 실행시간 제약은 생각보다 낮습니다.

input set이 존재합니다. 5 ~ 30이 있고 비슷하게 대응되는 세트가 있습니다. 모든 예측한 입출력이 서로 잘 대응해야 합니다. 다음은 실행시간을 기준으로 채점합니다. 실행시간 제약도 존재합니다. 파이썬으로 성능제약 문제는 거의 없습니다.

호환성이 문제가 되면 파이썬을 선택할 이유가 없습니다. 하지만 호환성은 상당히 좋습니다.

파이썬을 선택해야 할 엄청나게 좋은 이유는 코드가 간략하기 때문입니다. 코딩테스트에서는 제한된 시간안에 풀어야 합니다.

코딩테스트는 회사마다 환경이 다릅니다. 현재는 많은 경우 프로그래머스를 활용하고 있지만 다 다릅니다. 제한 시간은 생각보다 짧을 것입니다.

제한시간이 짧은데 타이핑 시간하고 소요시간도 비례합니다. 코드 변형을 관리하는데 코드가 길면 관리하기 위한 시간도 같이 늘어납니다.

언젠가는 코딩테스트 대회도 참가해야 합니다. 이럴 때 제출시간에 대한 가산점도 있습니다.

프로그램의 본질에 대해서입니다. 프로그램은 어떤 입력값이 있으면 의도한 값도 출력하는 것이 프로그램입니다. 이것을 구현하기 위해서는 자료구조 + 알고리즘 + ETC...입니다. 알고리즘은 생략해도 자료구조는 생략할 수 없습니다.

주어진 문제를 얼마나 쉽고 깔끔하게 해결하는가가 프로그래밍의 본질입니다. 결국 프로그램은 수단입니다. 그래서 쉽고 빠르고 간결하게 무엇을 어떻게 해결할지 잘 하는가입니다. 문제는 시험문제도 아니고 정형화되어 있지 않습니다.

요리에 비유하면 재료는 자료구조입니다. 알고리즘은 조리하는 방법입니다. 알고리즘 강의는 자료구조도 같이 가르칠 수 밖에 없습니다.

알고리즘은 공부할 때 학생마다 학습 곡선이 모두 다릅니다. 처음부터 잘하는 학생은 조그만한 방향만 주면 충분합니다. 하지만 못하는 학생은 선생님에게 의존할 수 밖에 없는 경우가 많습니다. 그래서 필요한 것은 자기객관화입니다. 학습효율이 좋으면 노력을 덜 할 수 있고 나쁘면 노력이 더 많이 필요합니다. 자기객관화는 마음으로 추론할 수 있습니다. 자만감과 자신감은 다릅니다. 자신이 없으면 학습이 더 필요한 것입니다. 자만은 더 심각하게 자기객관화도 못하는 사람입니다.

## 최댓값 찾기

코드를 보기 전에는 논리적으로 생각하는 시간을 갖기를 권장합니다.

어떤 개념이 치환된 것일 뿐입니다. 그 개념을 묘사하기 위한 각자의 방식이 있습니다.

알고리즘 구현을 꼭 굳이 사람이 글로 먼저 작성하는 이유는 간단합니다. 프로그래머의 인지부하를 줄이기 위해 하는 행위입니다. 파이썬에 익숙하기 전에는 사람에 말로 조금 익숙하다면 유사코드로 작성하기를 권장합니다.

옛날에 프론트엔드는 모든 GUI를 총칭했습니다. 지금은 웹의 UI를 주로 의미합니다.

가장 위험한 행위는 모르는데 알고있다고 하는 것입니다. 크게 혼납니다.

```py
# 자료입니다.
input = [3, 5, 6, 1, 2, 4]

# 처리입니다.
def fn(input):
    for row in array:               # 기준이 됩니다.
        for col in array:           # 대조군입니다.
            if row < col: break     # 대조군이 기준보다 크면 비교를 중단하고 다음 기준으로 넘어갑니다.

        else: return row

# 처리를 로우 레벨로 이해해보겠습니다.
[
    [3, 5, 6, 1, 2, 4],     # 3을 기준으로 5에서 중단됩니다.
    [3, 5, 6, 1, 2, 4],     # 5를 기준으로 6에서 중단됩니다.
    [3, 5, 6, 1, 2, 4],     # 6을 기준으로 중단이 없습니다.
    [3, 5, 6, 1, 2, 4],
    [3, 5, 6, 1, 2, 4],
    [3, 5, 6, 1, 2, 4]
]
```

대조군을 하나식 비교하기 위해 이중 for문을 사용합니다. 행렬로 사고해보면 이해할 수 있습니다. 가로 값 1개를 가지고 세로값을 계속 비교할 수 있습니다.

파이썬의 특이한점 중하나는 꿀문법이 많습니다. 문법설탕에 절였습니다. `for else`문도 지원합니다. List Comprehension 도 상당히 유용한 문법입니다.

파이썬은 들여쓰기가 강제입니다.

선무당이 사람잡습니다. 항상 조심해야 합니다. 확실하게 하는 것은 의심할 필요없습니다. 하지만 애매하게 알고 있으면 애매하게 알고 있다고 자각합니다.

최빈값이는 표현은 의외로 많이 사용하지 않습니다.

문자열 다루기에서 처음에는 `list`로 다루는게 직관적일 것입니다.

코딩테스트는 라이브러리를 제안합니다. 사용허가 불허가 각각 다릅니다. 기본 테크닉이 더 중요합니다.라이브러리는 일상 업무에 기본입니다. 하지만 코딩테스트는 제약을 둡니다. 확실히 기본기에 해당하는 언어 이해도 해당합니다.

참고로 파이썬은 for문과 if문이 생각보다 다양합니다.

강의는 자료구조 알고리즘이지만 파이썬을 통해 기본 문법학습도 함께합니다.

원시적인 방법 중하나는 코드 제너레이팅도 있습니다. for문을 돌아 txt파일에 문자열로 코드를 작서하고 확장자를 바꾸는 방법도 존재합니다.

강의 중 `alphabet = [0] * 26`을 보고 비트맵 자료구조라고 부릅니다. 비트맵은 특정 인덱스의 카운트를 높이는 자료구조입니다. 출현횟수를 기록하기 좋은 자료구조입니다.

아스키코드는 전혀 외울 필요없습니다. 물론 교양으로 암기하는 사람도 있습니다.

> 1962년 안시(ANSI)가 정의한 미국 표준 정보 교환 코드. 이 코드는 7비트의 이진수 조합으로 만들어져 총 128개의 부호를 표현한다. 아스키코드의 처음 32개(0-31)는 프린터나 전송 제어용으로 사용되고 나머지는 숫자와 로마글자 및 도량형 기호와 문장 기호를 나타낸다.
>
> 아스키(ASCII)는 7자리의 2진 코드인데 1비트의 패리티 비트를 추가하여 8개의 비트로 많은 컴퓨터에 사용되고 있다. 아스키(ASCII)코드의 비트 번호는 오른쪽에서 왼쪽으로 부여한다. 아스키(ASCII)는 여러 가지로 다양하게 사용되는 코드에 따른 정보 호환성의 제한이나 불편을 덜고, 컴퓨터 대 컴퓨터, 시스템의 통신을 단순화하고 표준화하기 위해 통신 장비의 사용자들과 자료 처리 사업자들이 협력하여 만들었다.
> [네이버 지식백과] 아스키 코드 [American Standard Code Information Interchange code] (한글글꼴용어사전, 2000. 12. 25., 세종대왕기념사업회)

코딩테스트에서는 보통 검색을 허용하지 않기 때문에 조금만 외우고 맵핑하면 됩니다. 아스키코드는 표준이기 때문에 활용하기 권장합니다. 다른 언어에서도 비슷한 기능을 기대해도 합리적일 것입니다. 하지만 맵핑하는 방식은 각자 다 다릅니다.

구글링을 빈도의 경중에 따라 개발능력 향상이 다릅니다. 단순하게 외우지 말도록 합니다. 한번 쓸 것이면 외우지 않습니다. 검색하는게 효율적입니다. 하지만 빈도가 높으면 가능하면 암기하도록 합니다. 자주 사용하는 라이브러리와 언어의 기능은 암기합니다. 알고리즘도 정말 자주사용하고 쉬운 것부터 암기합니다.

`continue`는 반복에서 다음으로 넘어가도록 하는 명령입니다.

자료구조와 알고리즘을 공부하는데 중요한 부분 중 개발자의 소양만이 아닙니다. 프로그래밍적 사고를 기르기 위한 수단도 됩니다.
