# 사견

알고리즘을 공부 안하면 SI 직행입니다. 단순코드 복붙합니다. 개발자로서 사고력을 함양할 수 없습니다.

메모리 효율적이거나 문제를 잘 해결하기 위해서는 자료구조와 알고리즘을 짝으로 알아야 합니다.

# 알고리즘

> 어떤 문제의 해결을 위하여, 입력된 자료를 토대로 하여 원하는 출력을 유도하여 내는 규칙의 집합. 여러 단계의 유한 집합으로 구성되는데, 각 단계는 하나 또는 그 이상의 연산을 필요로 한다.
>
> \- 표준국어대사전

간단하게는 문제를 해결하기 위한 유한한 절차의 합입니다.

알고리즘은 상황에 따라 효율성을 선택하는 기준이 다릅니다. 공간복잡성이 필요할 때와 시간복잡성이 필요할 때가 각각다릅니다.

자료구조와 알고르즘을 배우면 성능을 기준으로 좋은 코드와 나쁜 코드를 판단할 수 있습니다.

참고로 현업에서 일할 때는 이미 좋은 알고리즘이 다 구현되어 있습니다. 읽고 변형해서 사용하면 됩니다. 하지만 구현능력으로 개발자의 소양을 기르도록 합니다.

![Algorithm Growth](../img/1_iEbD3x2S5KOiEI6ZOltp9w.png)
Algorithm Growth입니다. 알고리즘의 시간복잡성을 나타내는 Big-O 표기법 그래프입니다.

[Algorithm Analysis & Time Complexity Simplified - 미디엄 아티클 클릭하지마세요. 제한 걸려있습니다.](https://randerson112358.medium.com/algorithm-analysis-time-complexity-simplified-cd39a81fec71)

알고리즘 분석은 중요합니다. Algorithm analysis is an important part of a broader computational complexity theory, which provides theoretical estimates for the resources (space and time)needed by any algorithm which solves a given computational problem. <-- 나머지는 미래의 저가 번역해줄 것입니다.

보통 시간복잡성이라고 하면 컴퓨터가 작업을 수행한 횟수를 말합니다.

Big-O (O), Big Omega (Ω) and Big Theta (Θ)가 각각 존재합니다.

Big-O (O)는 최악의 경우 Big Omega (Ω)는 최고의 경우 Big Theta (Θ)는 최고와 최악의 평균입니다.

보통은 최악의 경우를 대응해줍니다. 하지만 현실에서 모든 최악의 경우를 대응하지는 않습니다. 대응할 때마다 발생할 수익성을 판단하고 대응합니다.

알고리즘 분석으로 모든 강의가 회귀할 것입니다. 그래서 알고리즘 분석을 대충하지 말도록 합니다. 소프트웨어 엔지니어의 수학적 소양은 기본 중 기본입니다.

사람들이 자주 착각하는 것이 있는데 자료구조와 알고리즘은 서로 독립적이지 않습니다. 서로 짝을 이룹니다.

목차

1. [과제 구현 능력](#과제-구현-능력)
2. [배열(Array)과 연결된 리스트(Linked List)](#배열과-연결된-리스트)
3. [정렬(Sort), 스택(Stack), 큐(Queue), 해쉬(Hash)](#정렬sort-스택stack-큐queue-해쉬hash)
4. [힙(heap), BFS, DFS, Dynamic Programming](#힙heap-bfs-dfs-dynamic-programming)
5. [종합 알고리즘 문제 풀이](#종합-알고리즘-문제-풀이)

## 과제 구현 능력

### 최대값 찾기

```py
def find_max_num(array):
    # 이 부분을 채워보세요!
    return 1


print("정답 = 6 / 현재 풀이 값 = ", find_max_num([3, 5, 6, 1, 2, 4]))
print("정답 = 6 / 현재 풀이 값 = ", find_max_num([6, 6, 6]))
print("정답 = 1888 / 현재 풀이 값 = ", find_max_num([6, 9, 2, 7, 1888]))
```

간단한 문제입니다. 내장함수를 사용하는 방법과 사용하지 않는 2가지 모두 구현하도록 합니다.

pep는 파이썬 스타일가이드입니다.

지정변수, 초깃값 설정 전략을 활용할 수 있습니다.

### 최빈값 찾기

`isalpha()` 문자열 메서드를 사용해서 alphabet a ~ z 대소문자 모두 해당하는 알파벳인지 파악합니다. 띄어쓰기, 특수문자, 숫자는 `False`를 반환합니다.

`ord()` 내장함수는 아스키 (ASCII) 코드의 10진값을 조회할 수 있습니다.

```py
def find_max_occurred_alphabet(string):
    # 이 부분을 채워보세요!
    return "a"

print("정답 = a 현재 풀이 값 =", find_max_occurred_alphabet("Hello my name is sparta"))
print("정답 = a 현재 풀이 값 =", find_max_occurred_alphabet("Sparta coding club"))
print("정답 = s 현재 풀이 값 =", find_max_occurred_alphabet("best of best sparta"))
```

### 시간복잡도

시간복잡도는 입력자료량과 처리시간 사이 상관관계입니다. 시간복잡도가 낮을수록 성능이 좋은 프로그램이라고 할 수 있습니다.

시간복잡도를 계산하는 방법입니다. <strong> 1줄을 연산이라고 생각하면 간단합니다. </strong> 실제로는 더 복잡할 수 있습니다. 하지만 1줄 중에 반복문은 계수로 표현합니다.

자료입력은 많은 경우 함수(메서드)인자를 주로 의미합니다.

O(N) 방식으로 표현하는 이유는 시간복잡성은 가변적인 입력자료를 받기 때문에 추상화한 것입니다.

중첩 반복문을 사용해서 문제를 해결할 수 있지만 사용하지 말아야 할 이유입니다.

```py
for num in array:              # array 의 길이만큼 아래 연산이 실행
    for compare_num in array:  # array 의 길이만큼 아래 연산이 실행
        if num < compare_num:  # 비교 연산 1번 실행
            break
    else:
        return num
```

$$
N_{num} \times N_{compare\ num}
$$

즉 하나의 $N$개의 배열 원소를 넣으면 $N^{2}$번의 연산을 합니다. $O(N^{2})$ 시간복잡성을 갖습니다. 극도로 비효율적입니다.

```py
for num in array:      # array 의 길이만큼 아래 연산이 실행
    if num > max_num:  # 비교 연산 1번 실행
        max_num = num  # 대입 연산 1번 실행
```

반면 단순 반복문은 지금 코드에서는 $O(2N)$ 시간복잡성을 갖습니다. 하지만 보통 상수는 무시합니다. 그리고 가장 높은차의 계수(이 예시의 경우 $2N$ 중 2)도 무시합니다.

시간복잡성에서 집중할 것은 차수입니다.

대부분의 경우 지불하는 비용은 공간복잡도를 지불하고 시간복잡도 성능을 개선하는데 사용합니다.

### 공간복잡도

공간복잡도는 입력자료량과 할당하는 메모리량 사이 상관관계입니다. 대부분의 경우 시간복자도가 더 중요합니다. 하지만 공간복잡도 문제도 많이 출제합니다. 시간복잡도를 먼저 공부하고 대비한 다음에 대비하기를 권장합니다.

```py
alphabet_array = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"]
# -> 26 개의 공간을 사용합니다
max_occurrence = 0 # 1개의 공간을 사용합니다
max_alphabet = alphabet_array[0]   # 1개의 공간을 사용합니다.

for alphabet in alphabet_array:
    occurrence = 0  # 1개의 공간을 사용합니다
```

위 코드는 모두 상수만큼의 공간복잡도를 갖습니다.

### 점근 표기법(asymptotic notation)

알고리즘의 성능을 수학적으로 표기하는 방법입니다. 알고리즘의 “효율성”을 평가하는 방법입니다. 점근 표기법(asymptotic notation)은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법이다.

점근 표기법은 함수의 증가양상을 간단하게 비교로 표기한 해석학과 수론의 방법론입니다.

#### 배열에서 특정 요소 찾기

```py
# Q. 다음과 같은 숫자로 이루어진 배열이 있을 때, 이 배열 내에 특정 숫자가 존재한다면 True, 존재하지 않다면 False 를 반환하시오.
def is_number_exist(number, array):
    # 이 부분을 채워보세요!
    return True


result = is_number_exist
print("정답 = True 현재 풀이 값 =", result(3,[3,5,6,1,2,4]))
print("정답 = Flase 현재 풀이 값 =", result(7,[6,6,6]))
print("정답 = True 현재 풀이 값 =", result(2,[6,9,2,7,1888]))
```

이런 알고리즘을 풀기 위해서 하는 것은 선형탐색입니다. 순서대로 값을 찾습니다. 순서대로 순회해야 합니다. 또 최악의 경우는 입력한 자료량만큼 순회해야 합니다. 이럴때는 $O(N)$에 해당합니다.

알고리즘은 입력값의 분포에 따라서 성능이 다를 수 있습니다.

알고리즘은 최악의 경우가 대부분입니다. 그래서 최악의 경우를 대응하기 위해서 $Big-O$ 표기법을 사용합니다.

### 곱하기 or 더하기

```py
# Q. 다음과 같이 0 혹은 양의 정수로만 이루어진 배열이 있을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 '✕' 혹은 '+' 연산자를 넣어 결과적으로 가장 큰 수를 구하는 프로그램을 작성하시오.

# 단, '+' 보다 '✕' 를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서 순서대로 이루어진다.
def find_max_plus_or_multiply(array):
    # 이 부분을 채워보세요!
    return 1


result = find_max_plus_or_multiply
print("정답 = 728 현재 풀이 값 =", result([0,3,5,6,1,2,4]))
print("정답 = 8820 현재 풀이 값 =", result([3,2,1,5,9,7,4]))
print("정답 = 270 현재 풀이 값 =", result([1,1,1,3,3,2,5]))
# 풀이의 시간복잡도는 무엇인가요?
```

### 반복되지 않는 문자

```py
# Q. 다음과 같이 영어로 되어 있는 문자열이 있을 때, 이 문자열에서 반복되지 않는 첫번째 문자를 반환하시오. 만약 그런 문자가 없다면 _ 를 반환하시오.
input = "abadabac"

def find_not_repeating_first_character(string):
    # 이 부분을 채워보세요!
    return "_"


result = find_not_repeating_first_character
print("정답 = d 현재 풀이 값 =", result("abadabac"))
print("정답 = c 현재 풀이 값 =", result("aabbcddd"))
print("정답 =_ 현재 풀이 값 =", result("aaaaaaaa"))
# 풀이의 시간복잡도는 무엇인가요?
```

반복의 기준이 홀수번 등장한 문자입니다.

### 숙제

#### 소수 나열하기

```py
# Q. 정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오.
# 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다.

input = 20  # output = [2, 3, 5, 7, 11, 13, 17, 19]

def find_prime_list_under_number(number):
    # 이 부분을 채워보세요!
    return []


result = find_prime_list_under_number(input)
print(result)
# 시간복잡성을 묘사하십시오.
```

```py
# Q. 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자열에 있는 모든 숫자를 전부 같게 만들려고 한다. 할 수 있는 행동은 문자열에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

# 예를 들어 S=0001100 일 때,

# 전체를 뒤집으면 1110011이 된다.
# 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
# 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

# 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.

input = "011110"

def find_count_to_turn_out_to_all_zero_or_all_one(string):
    # 이 부분을 채워보세요!
    return 1

result = find_count_to_turn_out_to_all_zero_or_all_one(input)
print(result)
# 시간복잡성을 묘사하십시오.
```

```py
# Q.
# 1. 입력으로 소문자의 알파벳 순으로 정렬된 문자열이 입력됩니다.
# 2. 각 알파벳은 중복이 가능합니다.
# 3. 중간에 없는 알파벳이 있을 수도 있습니다.

# 입,출력 예시와 같이 입력 문자열에 나타나는 각 알파벳의 종류,갯수를 요약하여 나타내시오.

def summarize_string(input_str):
    # 이 부분을 채워보세요!

input_str = "acccdeee"

print(summarize_string(input_str))
# 시간복잡성을 묘사하십시오.
```

## 배열(Array)과 연결된 리스트(Linked List)

자료구조마다 효율적인 알고리즘이 각각 다릅니다. 프로그램에서 문제를 해결하는 또 다른 도구입니다.

연결된 리스트는 값과 다음 노드를 지정하는 방식입니다.

### 배열

배열은 크기가 정해진 연속된 데이터의 공간(메모리)입니다. 한번 정해지면 바꿀 수 없습니다. 배열은 원소에 즉시 접근(O(1) 시간복잡성)할 수 있습니다. 배열은 원소를 중간에 삽입하면 모든 원소를 움직여야 합니다. O(N) 시간복잡성을 갖습니다. 배열은 새로운 원소를 추가하기 위해서는 새로운 모두 옮겨주어야 하기 때문에 비효율적입니다.

현실에서는 요일별 먹어야 하는 알약통과 유사합니다. 오늘이 월요일이고 수요일에 어느약을 먹기 위에 중간에 넣으려면 다른 약들을 한칸식 옮겨 주어야 합니다. 상당히 비효율적입니다.

프로그래밍에서는 보통 변수는 한번에 하나씩 움직일 수 있습니다.

### 링크드 리스트

링크드 리스트 혹은 리스트는 혼용되는 용어입니다.

리스트는 크기가 정해지지 않은 데이터의 공간입니다. 크기가 자유롭게 키울 수 있습니다. 리스트는 특정 원소를 접근하려면 O(N) 시간복잡성을 갖습니다. 연결고리는 포인터 각 데이터 칸은 노드라고 합니다. 리스트는 중간에 삽입 삭제가 쉽습니다. 포인터만 변경하면 간단하게 할 수 있습니다. O(1) 시간복잡성으로 처리할 수 있습니다.

노드는 칸에 있는 데이터 다음칸이 무엇인지 알려주는 데이터 2가지를 가져야 합니다. 이럴 때는 클래스로 구현하는 것이 좋습니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

node = Node(3)
```

하나의 노드를 생성한 상태입니다. 그래서 포인터의 값은 `None`입니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

node1 = Node(3)
node2 = Node(12)
node1.next = node2

print(node1.data)       #  3
print(node1.next.data)  # 12
```

이렇게 하면 2개의 노드를 연결한 것입니다. `node1`은 머리고 `node2`는 꼬리에 해당합니다. `print`를 보면 `node1`을 통해서만 대입했습니다.

지금 만든 자료구조에서는 HeadNode만 저장하면 됩니다. 다음 노드들은 next 메서드로 접근하면 됩니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

class LinkedList:
    def __init__(self, data):
        self.head = Node(data)  # Head 역할을 할 Node를 할당합니다.

    def append(self, data):
        # 예외처리 Head가 없는 경우 append를 하면 Head로 할당해줍니다.
        if self.head is None:
            self.head = Node(data)
            return  # 메서드의 실행을 종료시킵니다.

        # Tail에 접근(선형탐색)
        cur = self.head
        while cur.next is not None:
            cur = cur.next

        # 추가
        cur.next = Node(data)

    def printAll(self):
        if self.head is None:
            print("empty")

        cur = self.head
        while cur is not None:
            print(cur.data)
            cur = cur.next

    # 인덱스 횟수만큼 이동하기 위해 for문을 사용합니다.
    def getNode(self, index):
        cur = self.head
        if index > 0:
            for idx in range(index):
                cur = cur.next
        return cur

    # 인덱스 번째 원소를 추가합니다.
    def addNode(self, index, value):
        newNode = Node(value)
        # head를 교체할 때
        if index == 0:
            newNode.next = self.head
            self.head = newNode
            return  #실행 종료

        prevNode = self.getNode(index - 1)  # [a] -> [b] -> [c] a랑 b사이 d를 추가할 때 b 이전 a를 선택합니다.
        nextNode = prevNode.next            # [b] 노드를 기록합니다.
        prevNode.next = newNode             # [a]의 다음 노드를 [d]를 바라보게 합니다. [a] -> [b] -> none  & [b] -> [c]
        newNode.next = nextNode             # [d]는 [b]를 바라보게 합니다. [a] -> [b] -> [b] -> [c]
        return  #실행 종료

    def deleteNode(self, index):
        # [a]를 삭제할 때
        if index == 0:
            self.head = self.getNode(index+1)
            return  #실행 종료

        # [d]를 삭제할 때
        if self.getNode(index).next == None:
            self.getNode(index-1).next = None
            return  #실행 종료

        # 유스케이스
        # [a] -> [b] -> [c] -> [d] 중에서 [c]를 삭제하기 위해 [b] 선택합니다.
        prevNode = self.getNode(index-1)
        # [a] -> [b] -> [d]로 포인터를 바꿉니다. [c]는 전후관계가 없어집니다. 메모리 누수가 있는지 모르겠습니다.
        prevNode.next = prevNode.next.next

# 5 -> 12 -> 8
linkedList = LinkedList(5)
linkedList.append(12)
linkedList.append(8)

linkedList.addNode(2, 3)
linkedList.deleteNode(3)
linkedList.printAll()
```

`LinkedList`입니다.

```py
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self, value):
        self.head = Node(value)

    def append(self, value):
        cur = self.head
        while cur.next is not None:
            cur = cur.next
        cur.next = Node(value)


def get_linked_list_sum(linked_list_1, linked_list_2):
    # 구현해보세요!
    return 1032


linked_list_1 = LinkedList(6)
linked_list_1.append(7)
linked_list_1.append(8)

linked_list_2 = LinkedList(3)
linked_list_2.append(5)
linked_list_2.append(4)

print(get_linked_list_sum(linked_list_1, linked_list_2))
```

`LinkedList`를 활용하는 문제입니다.

### Array vs Linked List

| 경우             | Array                                                                         | Linked List                                                  |
| ---------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------ |
| 특정 원소 조회   | O(1)                                                                          | O(N)                                                         |
| 중간에 삽입 삭제 | O(N)                                                                          | O(1)                                                         |
| 데이터 추가      | 데이터 추가 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받아야 한다 | 모든 공간이 다 찼어도 맨 뒤의 노드만 동적으로 추가하면 된다. |
| 정리             | 데이터에 접근하는 경우가 빈번하다면 Array를 사용하자                          | 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다. |

### 파이썬의 List

파이썬의 `list` 자료형은 배열로 구현되어 있습니다. 하지만 내부적으로 동적배열로 설계되어 있습니다. 파이썬은 Linked List, Array 모두 사용할 수 있습니다.

### 파이썬 클래스 다루기

클래스는 속성과 기능을 가진 객체를 총칭하는 개념입니다.

```py
class person:
    pass

jakeTheDog = person()
print(jakeTheDog)  # <__main__.person object at 0x1049c0a60>
```

`0x1049c0a60`은 메모리 주소입니다.

`person()`은 생성자 함수입니다. 함수가 실행되면 객체를 생성해줍니다. 그리고 `jakeTheDog` 식별자에 객체가 할당 되어 있습니다.

```py
class person:
    def __init__(self, name):  # 초기화 함수입니다. 생성자함수에 인자를 받아야 합니다.
        self.name = name  # 생성하면서 갖게 된 속성값입니다.
        print()

    def take(self):  # 메서드입니다. 메서드에는 첫번째 매개변수는 self여야 합니다.
        print('You stay away from my women! magic men')


jakeTheDog = person('jake')  # jakeTheDog 인스턴스를 생성한 것입니다.
print(jakeTheDog)  # <__main__.person object at 0x1049c0a60>
```

## 이진탐색과 선형탐색

소주게임 병뚜껑의 숫자를 맞추는 술게임 업다운이 있습니다. 대표적인 이진탐색 알고리즘을 실생활에 사용하는 경우입니다. 업다운은 알고리즘에서 어느것이 더 가까운지 알 수 있기 때문에 가운데를 찍고 맞췄는지 큰자 작은지 알아낼 수 있기 때문에 효율적입니다.

```py
finding_target = 14
finding_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]


def is_existing_target_number_binary(target, array):
    # 구현해보세요!
    return False


result = is_existing_target_number_binary(finding_target, finding_numbers)
print(result)
```

선형탐색은 $O(N)$ 시간복잡성을 갖습니다. 하지만 이진탐색은 $O(logN)$ 시간복잡성을 갖습니다.

이진탐색은 자료가 정렬되어 있어야 합니다.

## 재귀함수 Recursion

재귀함수는 자기자신을 반복적으로 호출하는 함수를 보고 재귀함수라고 합니다.

재귀함수를 활용하면 간략하고 효율적인 코드를 작성할 수 있습니다.

```py
def count_down(number):
    if number == 0: return
    print(number)          # number를 출력하고
    count_down(number - 1) # count_down 함수를 number - 1 인자를 주고 다시 호출한다!


count_down(60)
```

위코드는 재귀함수입니다. 재귀함수는 항상 베이스케이스 즉 종료조건부터 정의하고 다른 코드로 종료 조건을 유도하는 방식으로 작성합니다.

피보나치, 팩토리얼함수 등 구현하기 좋은 연습들이 존재합니다.

```py
def factorial(n):
    # 이 부분을 채워보세요!
    return 120

print(factorial(5))
```

베이스 케이스를 보고 특정숫자로 떨어지는 조건입니다.

회문은 일요일, 오디오, 토마토처럼 앞뒤로 똑같은 단어를 보고 하는 말입니다.

```py
input = "abcba"

def is_palindrome(string):
    return True

print(is_palindrome(input))
```

## 숙제

```py
# Q. 링크드 리스트의 끝에서 K번째 값을 반환하시오.
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self, value):
        self.head = Node(value)

    def append(self, value):
        cur = self.head
        while cur.next is not None:
            cur = cur.next
        cur.next = Node(value)

    def get_kth_node_from_last(self, k):
        # 구현해보세요!
        return self.head


linked_list = LinkedList(6)
linked_list.append(7)
linked_list.append(8)

print(linked_list.get_kth_node_from_last(2).data)  # 7이 나와야 합니다!
```

단순히 코드를 읽는 것만으로 시간복잡도를 추정하는 것은 옳지 않습니다. 컴퓨터가 표시하는 연산량을 신뢰하는 것이 더 좋습니다.

```py
'''
Q. 배달의 민족 서버 개발자로 입사했다.
상점에서 현재 가능한 메뉴가 ["떡볶이", "만두", "오뎅", "사이다", "콜라"] 일 때, 유저가 ["오뎅", "콜라", "만두"] 를 주문했다.

그렇다면, 현재 주문 가능한 상태인지 여부를 반환하시오.
'''
shop_menus = ["만두", "떡볶이", "오뎅", "사이다", "콜라"]
shop_orders = ["오뎅", "콜라", "만두"]


def is_available_to_order(menus, orders):
    # 이 부분을 채워보세요!
    return True


result = is_available_to_order(shop_menus, shop_orders)
print(result)
```

대부분의 정렬은 $O(N \cdot logN)$ 시간복잡도를 찾습니다.

중복없는 존재여부를 확인할 때는 집합(Set)으로 접근해볼 수 있습니다.

위문제를 이진탐색으로 풀어볼 수 있지만 집합연산을 활용하면 더욱더 우아하게 풀 수 있습니다. 오히려 이런 경우에는 이진탐색이 비효율적입니다.

이진탐색이 항상 효율적인 것이 아닙니다. 상황에 따라 효율이 다릅니다.

```py
'''
Q. 음이 아닌 정수들로 이루어진 배열이 있다. 이 수를 적절히 더하거나 빼서 특정한 숫자를 만들려고 한다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들기 위해서는 다음 다섯 방법을 쓸 수 있다.

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target_number이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 반환하시오.
'''
numbers = [1, 1, 1, 1, 1]
target_number = 3

def get_count_of_ways_to_target_by_doing_plus_or_minus(array, target):
    # 구현해보세요!
    return 5

print(get_count_of_ways_to_target_by_doing_plus_or_minus(numbers, target_number))  # 5를 반환해야 합니다!
```

문제의 경우의 수가 너무 크면 경우의 수를 축소하는 전략도 하나의 방법입니다.

경우의 수 문제는 $k^{n}$으로 접근해야 합니다.

파이썬에서는 함수에 원시형 자료를 받으면 복제하고 실행합니다. 사이드 이펙트를 막는 설계 같습니다.

함수에서 외부 자료를 변형하고 싶으면 `global` 키워드를 사용합니다.

## 정렬(Sort), 스택(Stack), 큐(Queue), 해쉬(Hash)

스택과 큐는 입출력이 정해진 자료구조입니다. 스택은 LIFO 큐는 FIFO입니다.

해쉬는 해쉬알고리즘으로 문자열을 고정된 길의 데이터를 만들 수 있습니다. 딕셔너리를 만들 때 사용할 수 있습니다. 블록체인에서 활용합니다.

### 정렬

정렬이란 데이터를 순서대로 나열하는 방법을 말합니다. 정렬은 다양한 전략들이 존재합니다.

정렬은 알고리즘에서 중요합니다. 이진탐색도 가능하고 데이터를 효율적으로 탐색할 수 있습니다.

정렬은 말로 표현하기 어려울 것입니다.

#### 버블정렬

가장 쉽고 직관적인 정렬방법입니다.

배열에서 2개식 읽으면서 순회합니다. 비교하고 조건에 따라 교환합니다. 오름차순이면 앞이 더 크면 교환합니다. 하지만 상당히 비효율적입니다.

```py
# 변수교환 문법
a = 2
b = 3
a, b = b, a
print(a, b)
```

```py
input = [4, 6, 2, 9, 1]

def bubble_sort(array):
    # 이 부분을 채워보세요!
    return array

bubble_sort(input)
print(input)  # [1, 2, 4, 6, 9] 가 되어야 합니다!

print("정답 = [1, 2, 4, 6, 9] / 현재 풀이 값 = ",bubble_sort([4, 6, 2, 9, 1]))
print("정답 = [-1, 3, 9, 17] / 현재 풀이 값 = ",bubble_sort([3,-1,17,9]))
print("정답 = [-3, 32, 44, 56, 100] / 현재 풀이 값 = ",bubble_sort([100,56,-3,32,44]))
```

이 알고리즘이 순회하는 방식은 비효율적일 것입니다.

1, 2, 3, 4, 5
1, 2, 3, 4
1, 2, 3
1, 2
1

이런 역삼각형 방식으로 순회하게 될 것입니다. $O(N^{2})$ 시간복잡성을 갖습니다.

#### 선택정렬

선택정렬은 이름처럼 선택하고 정렬하는 방식입니다.

```py
input = [4, 6, 2, 9, 1]


def selection_sort(array):
    # 이 부분을 채워보세요!
    return


selection_sort(input)
print(input) # [1, 2, 4, 6, 9] 가 되어야 합니다!

print("정답 = [1, 2, 4, 6, 9] / 현재 풀이 값 = ",selection_sort([4, 6, 2, 9, 1]))
print("정답 = [-1, 3, 9, 17] / 현재 풀이 값 = ",selection_sort([3,-1,17,9]))
print("정답 = [-3, 32, 44, 56, 100] / 현재 풀이 값 = ",selection_sort([100,56,-3,32,44]))
```

#### 삽입정렬

삽입정렬은 현재 정렬된 배열과 아닌 배열로 나눕니다. 보통 앞에 첫번째는 정렬된 것으로 봅니다. 다음 두번째 부터 삽입하고 비교합니다.

삽입정렬은 정렬된 배열에 새로운 원소를 배치하고 정렬하는 방식입니다.

```py
input = [4, 6, 2, 9, 1]

def insertion_sort(array):
    # 이 부분을 채워보세요!
    return

insertion_sort(input)
print(input) # [1, 2, 4, 6, 9] 가 되어야 합니다!

print("정답 = [4, 5, 7, 7, 8] / 현재 풀이 값 = ",insertion_sort([5,8,4,7,7]))
print("정답 = [-1, 3, 9, 17] / 현재 풀이 값 = ",insertion_sort([3,-1,17,9]))
print("정답 = [-3, 32, 44, 56, 100] / 현재 풀이 값 = ",insertion_sort([100,56,-3,32,44]))
```

#### 병합정렬

기술면접 질문의 수준입니다.

병합정렬은 배열의 앞부분과 뒷부분 그룹을 나누어 각각 정렬후 병합하는 알고리즘입니다.

```py
array_a = [1, 2, 3, 5]
array_b = [4, 6, 7, 8]

def merge(array1: list, array2: list):
    # 이 부분을 채워보세요!
    return

print(merge(array_a, array_b))  # [1, 2, 3, 4, 5, 6, 7, 8] 가 되어야 합니다!

print("정답 = [-7, -1, 5, 6, 9, 10, 11, 40] / 현재 풀이 값 = ", merge([-7, -1, 9, 40], [5, 6, 10, 11]))
print("정답 = [-1, 2, 3, 5, 10, 40, 78, 100] / 현재 풀이 값 = ", merge([-1,2,3,5,40], [10,78,100]))
print("정답 = [-1, -1, 0, 1, 6, 9, 10] / 현재 풀이 값 = ", merge([-1,-1,0], [1, 6, 9, 10]))
```

#### 분할정복 2 - 분할정복(Divide and Conquer)

merge sort

[3, 2, 4, 1]

이런 배열이 있으면 이 배열을 분할하고 정렬하고 합치는 전략입니다.

[3, 2],[4, 1]
[2, 3],[1, 4]

```py
array = [5, 3, 2, 1, 6, 8, 7, 4]

def merge_sort(array):
    if len(array) <= 1: return array
    mid = len(array)//2
    left_array = merge_sort(array[mid:])
    right_array = merge_sort(array[:mid])
    return merge(left_array, right_array)

def merge(array1: list, array2: list):
    mergeArray = []
    array2Index = 0
    array1Index = 0
    while array1Index < len(array1) and array2Index < len(array2):
        if array1[array1Index] < array2[array2Index]:
            mergeArray.append(array1[array1Index])
            array1Index += 1
        else:
            mergeArray.append(array2[array2Index])
            array2Index += 1

    # 남는 원소 처리
    while array1Index < len(array1):
        mergeArray.append(array1[array1Index])
        array1Index += 1

    while array2Index < len(array1):
        mergeArray.append(array1[array2Index])
        array2Index += 1

    return mergeArray

print(merge_sort(array))  # [1, 2, 3, 4, 5, 6, 7, 8] 가 되어야 합니다!

print("정답 = [-7, -1, 5, 6, 9, 10, 11, 40] / 현재 풀이 값 = ", merge_sort([-7, -1, 9, 40, 5, 6, 10, 11]))
print("정답 = [-1, 2, 3, 5, 10, 40, 78, 100] / 현재 풀이 값 = ", merge_sort([-1, 2, 3, 5, 40, 10, 78, 100]))
print("정답 = [-1, -1, 0, 1, 6, 9, 10] / 현재 풀이 값 = ", merge_sort([-1, -1, 0, 1, 6, 9, 10]))
```

하나의 함수가 다른 함수에 의존성을 갖은 시간복잡성을 갖고 있습니다.

`merge`함수는 $O(N)$ 선형시간복잡성을 갖습니다.

`merge_sort`는 $O(N \cdot logN)$ 시간복잡성을 갖습니다. ~~ 정확히 알고 있는 것은 아닙니다. 재귀함수로 배열의 반을 연속해서 호출하기 때문에 logN 시간복잡성을 갖습니다.~~

### 스택 Stack

![Stack & Queue](../img/image.png)

스택은 LIFO 형태의 자료구조입니다. 늦게 있으면 가장 위에 있는 개념입니다. 가장 위에 있어서 가장 먼저 뺄 수 있습니다. `Cmd` + `Z`같은 되돌리기 명령에 활용할 수 있습니다.

자료구조는 여러번 구현시도를 해야합니다.

```py
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, value):
        newStack = Node(value)
        newStack.next = self.head
        self.head = newStack

    # pop 기능 구현
    def pop(self):
        if self.is_empty(): return 'Stack은 비어있습니다.'
        # self.head를 조회합니다.
        stackPop = self.head
        # self.head를 삭제합니다.
        self.head = self.head.next
        return stackPop

    def peek(self):
        return self.head

    def is_empty(self):
        return self.head is None

stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)
print(stack.peek().data) # 30
print(stack.pop().data)  # 30
print(stack.pop().data)  # 20
print(stack.peek().data) # 10
```

스택을 직접 구현할 수 있지만 파이썬 자료형의 메서드를 활용해서 동일한 기능을 구현할 수 있습니다.

```py
stack = []            # 빈 스택 초기화
stack.append(4)       # 스택 push(4)
stack.append(3)       # 스택 push(3)
top = stack.pop()     # 스택 pop
print(top)            # 3!
```

연습문제입니다.

```py
'''
[6, 9, 5, 7, 4] # 라고 입력된다면,

# 아래 그림처럼 탑이 있다고 보시면 됩니다!
<- <- <- <- <- 레이저의 방향
   I
   I
   I     I
I  I     I
I  I  I  I
I  I  I  I  I
I  I  I  I  I
I  I  I  I  I
I  I  I  I  I

[0, 0, 2, 2, 4] # 다음과 같이 반환하시면 됩니다!
'''
top_heights = [6, 9, 5, 7, 4]


def get_receiver_top_orders(heights):
    return


print(get_receiver_top_orders(top_heights))  # [0, 0, 2, 2, 4] 가 반환되어야 한다!

print("정답 = [0, 0, 2, 2, 4] / 현재 풀이 값 = ",get_receiver_top_orders([6,9,5,7,4]))
print("정답 = [0, 0, 0, 3, 3, 3, 6] / 현재 풀이 값 = ",get_receiver_top_orders([3,9,9,3,5,7,2]))
print("정답 = [0, 0, 2, 0, 0, 5, 6] / 현재 풀이 값 = ",get_receiver_top_orders([1,5,3,6,7,6,5]))
# 시간복잡성을 묘사하십시오.
# O(N^2)
```

함수에서 받은 인자 자체를 `Stack`으로 취급해야 합니다.

### 큐 Queue

![Stack & Queue](../img/image.png)

한쪽에 데이터를 넣고 반대로 빼는 자료구조입니다. FIFO 혹은 선입선출 구조라고 합니다.

순서대로 처리해야 하는 일들에 사용합니다. 주문처리도 좋은 예시입니다.

큐는 링크드 리스트를 응용합니다. 처음과 끝 노드 모두 구현해야 합니다.

```py
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.tail = None

    def enqueue(self, value):
        newNode = Node(value)
        if self.is_empty():
            self.tail = newNode
            self.head = newNode
            return  # 실행종료

        newNode.next = self.tail
        self.tail = newNode

    def dequeue(self):
        if self.is_empty(): return 'empty'
        queuePop = self.head
        self.head = self.head.next
        return queuePop.data

    def peek(self):
        return self.head.data

    def is_empty(self):
        return self.head == None and self.tail == None
```

`head`를 먼저 뽑는 것이 올바릅니다. `head`가 밀리고 뽑을 때 나오게 됩니다. 자료를 적재할 때 가장 최근에 쌓인 자료는 `tail`에 있게 됩니다. 가장 마지막에 쌓인 자료는 `head`에 있게 됩니다.

```py
queue = [4, 5, 6]
queue.insert(0, 3)
queue.insert(0, 2)
print(queue)        # [2, 3, 4, 5, 6]
print(queue.pop())  # 6
print(queue.pop())  # 5
print(queue)        # [2, 3, 4]
```

### 해쉬

![해쉬 알고리즘](<../img/image%20(1).png>)

컴퓨팅에서 키를 값에 매핑할 수 있는 구조인, 연관 배열 추가에 사용되는 자료 구조입니다. 해시 테이블은 해시 함수를 사용하여 색인(index)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산합니다. 데이터를 다루는 기법 중에 하나로 데이터의 검색과 저장이 아주 빠릅니다.

파이썬의 딕셔너리랑 해쉬테이블과 유사한 자료구조입니다. 하지만 파이썬은 내부적으로 배열로 만듭니다.

본래 해쉬테이블은 키만 검색하면 되기 때문에 탐색 성능이 좋습니다.

파이썬에는 놀랍게도 해쉬함수를 제공합니다. `hash(object)` 내장함수입니다. 이 내장함수는 항상 임의의 값을 돌려줍니다.

해쉬테이블의 탐색시간이 $O(1)$ 시간복잡성을 갖습니다.

```py
class Dict:
    def __init__(self):
        self.items = [None] * 8

    def put(self, key, value):
        self.items[hash(key) % 8] = value
        return

    def get(self, key):
        return self.items[hash(key) % 8]
```

파이썬에서 DIY로 만든 `hash`입니다. `hash`내장함수는 `8`로 나누면 나머지(`%`)가 `0 ~ 7`이 나옵니다. 하지만 난수이기 때문에 덮어쓰기 충돌이 발생할 수 있습니다.

덮어쓰기 충돌을 막아야 합니다. 링크드 리스트를 활용하는 것도 전략입니다.

파이썬에서는 `tuple`자료형을 활용하는 전략이 있습니다.

```py
class LinkedTuple:
    def __init__(self):
        self.items = []

    def add(self, key, value):
        self.items.append((key, value))

    def get(self, key):
        for k, v in self.items:
            if k == key:
                return v
```

`tuple` 자료형은 불변입니다. 이 클래스는 덮어쓰기 문제가 없어집니다.

```py
class LinkedTuple:
    def __init__(self):
        self.items = []

    def add(self, key, value):
        self.items.append((key, value))

    def get(self, key):
        for k, v in self.items:
            if k == key:
                return v

class LinkedDict:
    def __init__(self):
        self.items = []
        for i in range(8):
            self.items.append(LinkedTuple())

    def put(self, key, value):
        self.items[hash(key) % len(self.items)].add(key, value)

    def get(self, key):
        return self.items[hash(key) % len(self.items)].get(key)


linkedDict = LinkedDict()
linkedDict.put('fast', '빠른')
linkedDict.get('fast')
```

이런 해결방식을 보고 체이닝이라고 부릅니다.

다른 방법은 배열의 다음 남는 공간에 담는 방법도 있습니다.

해쉬테이블은 키와 데이터를 저장하고 키로 데이터를 조회하는 방법입니다. 파이썬 딕셔너리 사용법과 동일합니다.

해쉬함수는 임의의 길이를 갖는 메시지를 입력해서 고정된 길의 임의의 값을 출력하는 함수입니다.

해쉬테이블의 검색은 $O(1)$상수시간복잡성을 갖습니다.

체이닝은 링크드 리스트 방식으로 해결할 수 있습니다. 개방주소법은 비어있을 때 체우는 방식입니다.

```py
'''
Q. 오늘 수업에 많은 학생들이 참여했습니다. 단 한 명의 학생을 제외하고는 모든 학생이 출석했습니다.

모든 학생의 이름이 담긴 배열과 출석한 학생들의 배열이 주어질 때, 출석하지 않은 학생의 이름을 반환하시오.
'''
all_students = ["나연", "정연", "모모", "사나", "지효", "미나", "다현", "채영", "쯔위"]
present_students = ["정연", "모모", "채영", "쯔위", "사나", "나연", "미나", "다현"]


def get_absent_student(all_array, present_array):
    # 구현해보세요!
    return


print(get_absent_student(all_students, present_students))

print("정답 = 예지 / 현재 풀이 값 = ",get_absent_student(["류진","예지","채령","리아","유나"],["리아","류진","채령","유나"]))
print("정답 = RM / 현재 풀이 값 = ",get_absent_student(["정국","진","뷔","슈가","지민","RM"],["뷔","정국","지민","진","슈가"]))
```

해쉬테이블은 검색이 효율적이지만 공간사용량이 많은 자료구조입니다.

### 숙제

```py
'''
Q.
다음과 같이 숫자로 이루어진 배열이 두 개가 있다.
하나는 상품의 가격을 담은 배열이고, 하나는 쿠폰을 담은 배열이다.
쿠폰의 할인율에 따라 상품의 가격을 할인 받을 수 있다.
이 때, 최대한 할인을 많이 받는다면 얼마를 내야 하는가?
단, 할인쿠폰은 한 제품에 한 번씩만 적용 가능하다.
'''
shop_prices = [30000, 2000, 1500000]
user_coupons = [20, 40]

def get_max_discounted_price(prices, coupons):
    # 이 곳을 채워보세요!
    return 0

print("정답 = 926000 / 현재 풀이 값 = ", get_max_discounted_price([30000, 2000, 1500000], [20, 40]))
print("정답 = 485000 / 현재 풀이 값 = ", get_max_discounted_price([50000, 1500000], [10, 70, 30, 20]))
print("정답 = 1550000 / 현재 풀이 값 = ", get_max_discounted_price([50000, 1500000], []))
print("정답 = 1458000 / 현재 풀이 값 = ", get_max_discounted_price([20000, 100000, 1500000], [10, 10, 10]))
```

```py
'''
Q. 괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻이다. 예를 들어

()() 또는 (())() 는 올바르다.
)()( 또는 (()( 는 올바르지 않다.

이 때, '(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 True 를 반환하고 아니라면 False 를 반환하시오.
'''
def is_correct_parenthesis(string):
    # 구현해보세요!
    return


print("정답 = True / 현재 풀이 값 = ", is_correct_parenthesis("(())"))
print("정답 = False / 현재 풀이 값 = ", is_correct_parenthesis(")"))
print("정답 = False / 현재 풀이 값 = ", is_correct_parenthesis("((())))"))
print("정답 = False / 현재 풀이 값 = ", is_correct_parenthesis("())()"))
print("정답 = False / 현재 풀이 값 = ", is_correct_parenthesis("((())"))
```

```py
'''
Q. 멜론에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 한다.

노래는 인덱스 구분하며, 노래를 수록하는 기준은 다음과 같다.

1. 속한 노래가 많이 재생된 장르를 먼저 수록한다. (단, 각 장르에 속한 노래의재생 수 총합은 모두 다르다.)

2. 장르 내에서 많이 재생된 노래를 먼저 수록한다.

3. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록한다.


노래의 장르를 나타내는 문자열 배열 genres와
노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때,

베스트 앨범에 들어갈 노래의 인덱스를 순서대로 반환하시오.
'''
def get_melon_best_album(genre_array, play_array):
    # 구현해보세요!
    return []


print("정답 = [4, 1, 3, 0] / 현재 풀이 값 = ", get_melon_best_album(["classic", "pop", "classic", "classic", "pop"], [500, 600, 150, 800, 2500]))
print("정답 = [0, 6, 5, 2, 4, 1] / 현재 풀이 값 = ", get_melon_best_album(["hiphop", "classic", "pop", "classic", "classic", "pop", "hiphop"], [2000, 500, 600, 150, 800, 2500, 2000]))
```

## 힙(heap), BFS, DFS, Dynamic Programming

여기까지는 알고리즘 개념입니다. 다음주는 풀이입니다.

### 트리

![트리](../img/%ED%8A%B8%EB%A6%AC.jpeg)

### 힙(heap)

![min heap과 max heap 비교](../img/Untitled.png)

heap 자료는 계층구조를 갖고 있습니다. min heap, max heap

### BFS, DFS

![BFS와 DFS 비교](../img/image.gif)

BFS는 경로 우선탐색입니다.

DFS는 깊이 우선탐색입니다.

### Dynamic Programming

![Dynamic Programming 그림](<../img/image%20(3).png>)

동적 계획법 DP라고 줄여서 말합니다. 부분의 해를 구해서 전체 문제를 푸는 방법입니다.

## 종합 알고리즘 문제 풀이

## 문제풀이 접근 방법

알고리즘 문제를 풀다보면, 문제 자체를 이해하기 힘들 때가 있습니다.

코드부터 작성하지 않습니다. 다른 케이스들의 규칙성을 파악하기 바랍니다.

배웠던 자료구조와 알고리즘 중 무엇으로 해결할 수 있는지 파악해봅니다.

문제의 특징을 하나식 글로 작성해봅니다.

수학적 성질 혹은 개념을 응용합니다. 평소 수학관련 교양을 쌓도록 합니다.

특정숫자의 특징 혹은 성질을 늘고민합니다.

문제를 독해할 때 무엇을 반환해야 하는지 유심히 읽어봅니다. 자료에 변형을 가한 그 자체인지 자료에 변형을 가하기 위한 횟수가 몇번진 등 간접적일 수 있습니다.

# 강창민 튜터 추가 특강

코딩테스트는 주로 지정해주지 않습니다. 지원자가 선택할 수 있는 경우가 많습니다.

알고리즘은 언어를 배울 때랑 또 격이 다릅니다. 알고리즘을 공부할 때 조금만 방향을 제공해주면 성장을 빠르게 할 수 있습니다.

알고리즘은 코딩테스트에 도전할 용기를 배우는 것도 중요합니다.

코딩테스트는 헬스랑 비슷합니다. 하기 싫지만 하면 엄청나게 성장할 수 있습니다. 알고리즘을 잘하는데 구현을 못하는 사람은 없습니다.

좋은 회사는 대부분의 경우 코딩테스트를 봅니다. 이력서는 30초 정도 판단합니다. 지인 추천은 검증되어 있어서 확정입니다.

코딩테스트는 좋은 회사가 정량적으로 무능한 지원자를 거를 수 있는 허들입니다.

어느 자료형을 사용해도 예를 들어 순서가 있고 없고 규칙을 암기하는 것은 의미가 없습니다. 왜 순서가 없는지 이 설계의도를 탐구해보기를 권장합니다.

코딩테스트에서 파이썬을 권장하는 이유는 가장 많이 사용하기 때문입니다. 자바는 거의 사용하지 않습니다. 자바스크립트는 의외로 맍습니다.

파이썬은 pypy3로 성능개선을 할 수 있습니다. 실행시간 제약은 생각보다 낮습니다.

input set이 존재합니다. 5 ~ 30이 있고 비슷하게 대응되는 세트가 있습니다. 모든 예측한 입출력이 서로 잘 대응해야 합니다. 다음은 실행시간을 기준으로 채점합니다. 실행시간 제약도 존재합니다. 파이썬으로 성능제약 문제는 거의 없습니다.

호환성이 문제가 되면 파이썬을 선택할 이유가 없습니다. 하지만 호환성은 상당히 좋습니다.

파이썬을 선택해야 할 엄청나게 좋은 이유는 코드가 간략하기 때문입니다. 코딩테스트에서는 제한된 시간안에 풀어야 합니다.

코딩테스트는 회사마다 환경이 다릅니다. 현재는 많은 경우 프로그래머스를 활용하고 있지만 다 다릅니다. 제한 시간은 생각보다 짧을 것입니다.

제한시간이 짧은데 타이핑 시간하고 소요시간도 비례합니다. 코드 변형을 관리하는데 코드가 길면 관리하기 위한 시간도 같이 늘어납니다.

언젠가는 코딩테스트 대회도 참가해야 합니다. 이럴 때 제출시간에 대한 가산점도 있습니다.

프로그램의 본질에 대해서입니다. 프로그램은 어떤 입력값이 있으면 의도한 값도 출력하는 것이 프로그램입니다. 이것을 구현하기 위해서는 자료구조 + 알고리즘 + ETC...입니다. 알고리즘은 생략해도 자료구조는 생략할 수 없습니다.

주어진 문제를 얼마나 쉽고 깔끔하게 해결하는가가 프로그래밍의 본질입니다. 결국 프로그램은 수단입니다. 그래서 쉽고 빠르고 간결하게 무엇을 어떻게 해결할지 잘 하는가입니다. 문제는 시험문제도 아니고 정형화되어 있지 않습니다.

요리에 비유하면 재료는 자료구조입니다. 알고리즘은 조리하는 방법입니다. 알고리즘 강의는 자료구조도 같이 가르칠 수 밖에 없습니다.

알고리즘은 공부할 때 학생마다 학습 곡선이 모두 다릅니다. 처음부터 잘하는 학생은 조그만한 방향만 주면 충분합니다. 하지만 못하는 학생은 선생님에게 의존할 수 밖에 없는 경우가 많습니다. 그래서 필요한 것은 자기객관화입니다. 학습효율이 좋으면 노력을 덜 할 수 있고 나쁘면 노력이 더 많이 필요합니다. 자기객관화는 마음으로 추론할 수 있습니다. 자만감과 자신감은 다릅니다. 자신이 없으면 학습이 더 필요한 것입니다. 자만은 더 심각하게 자기객관화도 못하는 사람입니다.

## 최댓값 찾기

코드를 보기 전에는 논리적으로 생각하는 시간을 갖기를 권장합니다.

어떤 개념이 치환된 것일 뿐입니다. 그 개념을 묘사하기 위한 각자의 방식이 있습니다.

알고리즘 구현을 꼭 굳이 사람이 글로 먼저 작성하는 이유는 간단합니다. 프로그래머의 인지부하를 줄이기 위해 하는 행위입니다. 파이썬에 익숙하기 전에는 사람에 말로 조금 익숙하다면 유사코드로 작성하기를 권장합니다.

옛날에 프론트엔드는 모든 GUI를 총칭했습니다. 지금은 웹의 UI를 주로 의미합니다.

가장 위험한 행위는 모르는데 알고있다고 하는 것입니다. 크게 혼납니다.

```py
# 자료입니다.
input = [3, 5, 6, 1, 2, 4]

# 처리입니다.
def fn(input):
    for row in array:               # 기준이 됩니다.
        for col in array:           # 대조군입니다.
            if row < col: break     # 대조군이 기준보다 크면 비교를 중단하고 다음 기준으로 넘어갑니다.

        else: return row

# 처리를 로우 레벨로 이해해보겠습니다.
[
    [3, 5, 6, 1, 2, 4],     # 3을 기준으로 5에서 중단됩니다.
    [3, 5, 6, 1, 2, 4],     # 5를 기준으로 6에서 중단됩니다.
    [3, 5, 6, 1, 2, 4],     # 6을 기준으로 중단이 없습니다.
    [3, 5, 6, 1, 2, 4],
    [3, 5, 6, 1, 2, 4],
    [3, 5, 6, 1, 2, 4]
]
```

대조군을 하나식 비교하기 위해 이중 for문을 사용합니다. 행렬로 사고해보면 이해할 수 있습니다. 가로 값 1개를 가지고 세로값을 계속 비교할 수 있습니다.

파이썬의 특이한점 중하나는 꿀문법이 많습니다. 문법설탕에 절였습니다. `for else`문도 지원합니다. List Comprehension 도 상당히 유용한 문법입니다.

파이썬은 들여쓰기가 강제입니다.

선무당이 사람잡습니다. 항상 조심해야 합니다. 확실하게 하는 것은 의심할 필요없습니다. 하지만 애매하게 알고 있으면 애매하게 알고 있다고 자각합니다.

최빈값이는 표현은 의외로 많이 사용하지 않습니다.

문자열 다루기에서 처음에는 `list`로 다루는게 직관적일 것입니다.

코딩테스트는 라이브러리를 제안합니다. 사용허가 불허가 각각 다릅니다. 기본 테크닉이 더 중요합니다.라이브러리는 일상 업무에 기본입니다. 하지만 코딩테스트는 제약을 둡니다. 확실히 기본기에 해당하는 언어 이해도 해당합니다.

참고로 파이썬은 for문과 if문이 생각보다 다양합니다.

강의는 자료구조 알고리즘이지만 파이썬을 통해 기본 문법학습도 함께합니다.

원시적인 방법 중하나는 코드 제너레이팅도 있습니다. for문을 돌아 txt파일에 문자열로 코드를 작서하고 확장자를 바꾸는 방법도 존재합니다.

## 최빈값찾기

강의 중 `alphabet = [0] * 26`을 보고 비트맵 자료구조라고 부릅니다. 비트맵은 특정 인덱스의 카운트를 높이는 자료구조입니다. 출현횟수를 기록하기 좋은 자료구조입니다.

아스키코드는 전혀 외울 필요없습니다. 물론 교양으로 암기하는 사람도 있습니다.

> 1962년 안시(ANSI)가 정의한 미국 표준 정보 교환 코드. 이 코드는 7비트의 이진수 조합으로 만들어져 총 128개의 부호를 표현한다. 아스키코드의 처음 32개(0-31)는 프린터나 전송 제어용으로 사용되고 나머지는 숫자와 로마글자 및 도량형 기호와 문장 기호를 나타낸다.
>
> 아스키(ASCII)는 7자리의 2진 코드인데 1비트의 패리티 비트를 추가하여 8개의 비트로 많은 컴퓨터에 사용되고 있다. 아스키(ASCII)코드의 비트 번호는 오른쪽에서 왼쪽으로 부여한다. 아스키(ASCII)는 여러 가지로 다양하게 사용되는 코드에 따른 정보 호환성의 제한이나 불편을 덜고, 컴퓨터 대 컴퓨터, 시스템의 통신을 단순화하고 표준화하기 위해 통신 장비의 사용자들과 자료 처리 사업자들이 협력하여 만들었다.
> [네이버 지식백과] 아스키 코드 [American Standard Code Information Interchange code] (한글글꼴용어사전, 2000. 12. 25., 세종대왕기념사업회)

코딩테스트에서는 보통 검색을 허용하지 않기 때문에 조금만 외우고 맵핑하면 됩니다. 아스키코드는 표준이기 때문에 활용하기 권장합니다. 다른 언어에서도 비슷한 기능을 기대해도 합리적일 것입니다. 하지만 맵핑하는 방식은 각자 다 다릅니다.

구글링을 빈도의 경중에 따라 개발능력 향상이 다릅니다. 단순하게 외우지 말도록 합니다. 한번 쓸 것이면 외우지 않습니다. 검색하는게 효율적입니다. 하지만 빈도가 높으면 가능하면 암기하도록 합니다. 자주 사용하는 라이브러리와 언어의 기능은 암기합니다. 알고리즘도 정말 자주사용하고 쉬운 것부터 암기합니다.

`continue`는 반복에서 다음으로 넘어가도록 하는 명령입니다.

자료구조와 알고리즘을 공부하는데 중요한 부분 중 개발자의 소양만이 아닙니다. 프로그래밍적 사고를 기르기 위한 수단도 됩니다.

코딩테스트를 볼 때 혼자공부할 때는 위축되어서는 안 됩니다. 현실에서 볼 때는 많이 위축되기 쉽습니다. 연습마저 위축되면 곤란합니다.

1번째 풀이법은 첫번째보단 비효율적이라고 할 수 있습니다.

접근하는 법입니다. 알파벳을 순서대로 배열에 저장합니다. 그리고 순회하면서 하니씩 알아냅니다. 부르트포스 기법에 해당합니다.

시간복잡도는 무의식적으로 미비하게 인지하고 있는 경우가 있습니다. for문을 덜 돌수록 효율적이라고 추론하는 것과 비슷합니다. 이것을 정량적으로 분류한 것입니다.

시간복잡도는 Time complexity는 TC라고 짧게 부릅니다.

코딩테스트에서 시간복잡도를 구하지는 않고 전산학개론에서 질문하는 경우가 있습니다. 대략 분류하고 파악하는 개념을 중심으로 알고 있도록 합니다.

시간복잡도는 최악의 경우의 수를 기준으로 계산합니다.

시간복잡도는 주요 반복문 혹은 비즈니스로직 위주로 대입하고 계산합니다. 상수항은 무시합니다. 하지만 계수는 주의하도록 합니다. $O(2N)$ 표기는 합리적입니다.

시간복잡도는 어려운 개념은 아닙니다. 하지만 시간복잡도 개념이 공간복잡도 보다는 훨씬 중요합니다. 공간복잡도는 9:1로 공부하기를 권장합니다. 공간복잡도는 다른 기능의 리소스를 너무 낭비하지 않을 정도로 사용합니다.

프로그램을 설계할 때는 리소스 최대사이즈 설계 이외에는 거의 필요한 경우가 많지 않습니다. 공간복잡도는 메모리 제약수준 정도입니다.

현업에서는 시간복잡도는 머리속에서 바로 나와야 합니다. 보고 코드퀄리티를 바로 추측할 수 있어야 합니다.

이중 for문을 사용할 수밖에 없는 상황에서는 사용해야 합니다. 그리고 그럴 수밖에 없는 비즈니스로직이 발생하는 경우도 존재합니다.

컴퓨팅의 본질은 일을 덜 시키고 더 많은 계산 결과를 얻어 내는 것입니다.

변수의 개수보단 데이터의 크기가 더 중요합니다. 공간복잡도를 결정하는 법은 데이터의 구조와 크기로 추정해야 합니다. 즉 메모리가 수용할 수 있는 그릇을 초과했는지 알아내야 합니다.

$O(N^{2})$는 상당히 성능이 안좋은 알고리즘 맞습니다. 또 상수항도 크면 시간복잡도에 영향을 줄 수 있습니다. 그리고 $y = wx + z$ 계수($w$)도 성능에 큰 영향을 줍니다.

접근표기법보단 $Big-O$ 표기법, $Big-\Omega$이라는 용어에 더 익숙합니다.

알고리즘은 입력값의 분포에 따라 성능이 변화할 수 있습니다. 그래서 입력값을 고르게 하기 위해서 정렬을 합니다.

$Big-\Omega$는 실무적으로 사용할 일이 사실상 없습니다.

## 2장 해설

재귀함수는 이월하겠습니다.

자료구조 선택기준:

1. 삽입시간
2. 삭제시간
3. 검색시간
4. 정렬여부

자료구조를 선택할 때 최선을 선택하는 방법입니다. 공학은 항상 트레이드오프를 생각해야 합니다. 상황과 맥락이 최선을 결정합니다.

### 배열

배열을 언어에 내장되어 있는 경우가 많아서 쉽게 알 수 있습니다.

대부분의 배열은 검색시간은 상수시간 시간복잡성을 갖습니다. 하지만 전제가 있습니다. 인덱스를 상수로 알 수 있어야 한번에 접근할 수 있습니다. 하지만 모르면 상수시간에 접근할 수 없습니다. 인덱스를 사전에 알면 효율적입니다. 또 재정렬, 삽입 등은 다른 작업에서는 비효율적입니다.

배열은 고정된 크기에 좋은 자료구조입니다.

### 링크드 리스트

링크드 리스트는 배열과는 전혀다른 개념입니다.

링크드 리스트는 삽입과 삭제에 자유롭습니다. 연속하는 자료형입니다. 어디 삽입할 지는 포인터 속성값만 변형하면 됩니다.

하지만 접근하기 위해서는 항상 head부터 할수밖에 없습니다. 포인터 중간을 건너뛸 수 없습니다.

일반 링크드 리스트랑 더블 링크드 리스트가 있습니다. 더블링크 리스트는 역순회(traverse)할 수 있습니다. 쌍방으로 움직일 수 있습니다. 순회는 forward 순회와 역순회 2가지 있습니다.

`curr`은 current를 짧게 부를 때사용합니다.

```py
class Node:
    def __init__(self, data) -> None:
        self.data = data  # 여기는 필요한 자료를 할당할 수 있습니다.
        self.next = None  # 처음에는 연결할 게 없습니다. 여기 속성값이 포인터 역할을 합니다.

class LinkedList:
    def __init__(self, data):
        self.head = Node(data)  # Head 역할을 할 Node를 할당합니다.

    def append(self, data):
        # 예외처리 Head가 없는 경우 append를 하면 Head로 할당해줍니다.
        if self.head is None:
            self.head = Node(data)
            return  # 메서드의 실행을 종료시킵니다.

        # Tail에 접근(선형탐색)
        cur = self.head
        while cur.next is not None:
            cur = cur.next

        # 추가
        cur.next = Node(data)
```

여기서 cur는 프로그래밍 개념적으로 엔트리포인트입니다. 접근하기 위한 경로입니다.

링크드 리스트를 사용할 때 결정적인 장점은 삽입삭제가 간단합니다.

알고리즘 공부할 때는 도식화도 하는 것을 권장합니다. 인지부하를 많이 줄여줍니다. 그리고 이런 노력을 충분히 해보도록 합니다. 실력있는 개발자들도 어려우면 그림을 꽤 많이 그립니다.

대부분의 두려움은 인지부하를 초과하고 문제를 해결하지 못할 때입니다. 필기구를 사용해서 생각정리를 적극적으로 해보기 바랍니다.

`-1` 예외처리는 항상 고려하도록 하시기 바랍니다. 자주 발생할 것입니다.

### 재귀함수

재귀함수에 대한 개념도 다루겠습니다.

베이스 케이스를 보고 다른 말로 터미널 컨디션이라고 합니다. 함수가 종료할 조건입니다.

함수형 언어는 반복문이 없어서 재귀함수로 처리하는 경우도 있습니다. 함수형 언어의 기본 중 기본입니다.

Tail Recursion은 나중에 자습하면서 꼭 알아내도록 합니다.

반복문을 사용하면 당연히 직관적이라 좋습니다. 하지만 코드를 잘 정리할 때 사용합니다. 코딩테스트에서 재귀함수 시험문제도 자주 출제합니다. 코딩테스트는 터미널 컨디션을 여러개 설정하도록 합니다.

재귀함수는 Stack에 push하고 터미널 컨디션에 도달하면 모두 pop합니다.

실용적이지 않지만 회문검사같은 문제는 코딩테스트는 자주 나옵니다.

콘솔이나 터미널에서 간단하게 코드를 작성할 수 있는 환경을 보고 REPL이라고 합니다. Read Eval Print Loop도 약자입니다.

```py
# 결국 못 풀었습니다.

numbers = [1, 1, 1, 1, 1]
target_number = 3
result_count = 0  # target 을 달성할 수 있는 모든 방법의 수를 담기 위한 변수

def get_count_of_ways_to_target_by_doing_plus_or_minus(array, target, current_index, current_sum):

get_count_of_ways_to_target_by_doing_plus_or_minus(numbers, target_number, 0, 0)  # 5를 반환해야 합니다!
print(result_count)
```

경우의 수는 $(연산자의 개수)^{숫자의 개수}$로 접근합니다. 이런 문제는 반복문으로도 풀 수 있습니다. 반복문으로 풀 수 있는 이유입니다. 먼저 연산은 2가지만 존재합니다. 컴퓨터는 바이너리 표현에 최적화 되어 있습니다. 그리고 모두 1로 되어 있습니다. 경우의 수는 "----- ~ +++++"으로 표현할 수 있습니다.

```py
numbers = [1, 1, 1, 1, 1]
target = 3

def fn(numbers: list, target: int) -> int:
    for i in range(2**len(numbers)):
        # 바이너리 변환
        binaryVal = '{:05b}'.format(i)
        binaryArray = [int(elem) for elem in list(binaryVal)]
        curSum = numbers[0] if binaryArray[0] == 1 else -numbers[0
```

생각을 작은 단위로 정확히 알고 빠르게 만들어야 합니다.
