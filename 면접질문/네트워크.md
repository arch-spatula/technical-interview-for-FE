https://yozm.wishket.com/magazine/detail/1875/

https://yozm.wishket.com/magazine/detail/1906/

https://bitkunst.tistory.com/entry/ABOUTSeries-2-URI-URL-URN

# CDN이란 뭔가요?

- CDN은 유저의 요청에 대한 캐시와 비슷합니다. HTTP 요청을 활용하고 있다면 동일한 콘텐츠에 대해서 캐싱을 시키고 동일한 콘텐츠 요청이 또 발생하면 엣지 서버에서 바로 응답하게 됩니다.

---

[What Is A CDN? How Does It Work?](https://www.youtube.com/watch?v=RI9np1LWzqw)

- CDN이란 무엇이고 왜 사용하는가?
- 놀랍게도 1998년대에도 사용중이었습니다. 원래 정적인 HTML 페이지를 빠르게 전달하기 위해 만들어졌습니다.
- CDN은 엄청나게 발전했습니다. CDN은 HTTP로 트레픽이 발생하면 자주 활용합니다.
- 모던 CDN은 근본적으로 또 물리적으로 사용자에게 콘텐츠를 더 가까운 곳에서 제공합니다. 웹 서비스 성능이 좋아집니다.
- CDN은 세계적으로 서버가 많이 위치하고 있습니다. 이런 서버들을 보고 Pop(Point of Presence)라고 합니다. Pop 속에 있는 서버를 흔히 엣지 서버라고 부릅니다.
- 글로벌 단위 제품에서 Pop을 다양한 곳에 위치시켜야 유저가 빠르게 접근할 수 있게 해줍니다.
- CDN마다 사용하는 기술은 모두 다릅니다. 하지만 공통적으로 가장 가까운 Pop으로 가도록 하는 결과만 같습니다.
- 많이 사용하는 요청은 DNS 기반 라우팅과 Anycast입니다.
  - DNS 기반라우팅은 각각의 Pop이 각각 IP 주소를 갖습니다. 사용자가 CDN IP를 조회하면 DNS는 가장 가까운 Pop IP를 반환합니다.
  - Anycast에서는 모든 Pop들이 같은 IP 주소를 공유합니다. 만약 요청이 Anycast 네트워크로 발생하면 네트워크는 가장 가까운 Pop으로 보냅니다.
- 각각의 엣지서버는 콘텐츠 캐시를 보유하면서 리버스 프록시처럼 행동합니다.
  - 정적인 콘텐츠는 엣지서버에 캐싱시킵니다. 이것은 콘텐츠 캐시입니다. 만약 캐싱이 되어 있으면 유저가 빠르게 받을 수 있습니다.
  - 하지만 엣지서버는 콘텐츠 캐시의 복사본만 갖고 있습니다. 이렇게만 해도 오리진 서버의 로드와 대역폭을 줄입니다.
- 모던 CDN은 더 최적화된 형태로 보관할 수 있습니다. 자바스크립트 번들, 이미지 확장자 변경 등을 수행할 수 있습니다.
- 엣지서버는 현대 http 스택에 중요한 역할을 합니다.
- 모든 TLS 연결은 엣지에서 끊습니다. TLS 핸드쉐이크는 비쌉니다. 엣지에서 끊으면 유저에게 지연시간이 덜 발생합니다.
  - 이런 이유로 캐싱할 수 없고 동적인 콘텐츠도 캐싱하려고 합니다.
- 성능 이외의 이점도 존재합니다. 대규모 DDos 공격으로부터 방어가 가능합니다.
  - Anycast 네트워크 기반 CDN에 특히 더 효율적입니다. 공격 트레픽을 여러 서버로 나눌 수 있습니다.
- 안정성에서도 유리합니다. 하나의 하드웨어 서버 문제가 발생해도 그 다음으로 가까운 Pop에서 처리할 수 있습니다.
- 모던 CDN은 다양한 이점이 있습니다. HTTP로 트레픽이 발생하면 충분히 고민해볼만 합니다.

[What is a Content Delivery Network (CDN)?](https://www.youtube.com/watch?v=Bsq5cKkS33I)

- 아주 짧게 요약하자면 CDN은 콘텐츠 전달을 가속화하는 서비스입니다.
- 동작방식을 이해하기 전에 전세계에 유저가 있지만 서버는 없던 시대부터 다루겠습니다.
  - 물리적으로 서버 위치와 멀수록 요청과 응답시간이 더 걸릴 것입니다. CDN은 이런 상황에 필요합니다.
- 세계적유저가 이용하고 있으면 CDN의 종담점을 유저가 있는 곳마다 배치해야 합니다.
- 유저가 어떤 콘텐츠를 접근하려고 CDN 서비스로 먼저 접근합니다. 아직 CDN 서버로 받은 것은 아닙니다. 최초 요청이 있으면 오리진 서버는 엣지서버에게 유저가 요청한 콘텐츠를 캐싱시키도록 합니다. 이렇게 되면 동일한 콘텐츠를 요청한 유저는 캐시를 통해 확인하게 됩니다.
  - 여기서 생기는 장점은 엣지서버가 요청과 응답을 캐시하고 처리하기 때문에 오리진 서버의 부하가 덜 발생합니다.
  - 하나의 요청이 다른 엣지서버에 배포를 하게 됩니다.
- 오리진 서버의 부담이 덜하기 때문에 로드가 덜합니다. 또 가동시간도 처리량이 줄어서 좋아집니다. 또 모호함을 통해 보안상 보호도 받게 됩니다.

# TTFB

- TTFB(Time to First Byte)는 HTTP 요청을 했을때 처음 byte (정보) 가 브라우져에 도달하는 시간을 의미합니다.
- 이것은 서버의 통신 성능입니다.
- 브라우저가 http 요청을 보내고 서버로부터 최초 응답을 받을 때까지 걸리는 시간입니다. 브라우저 성능, DNS, TCP, Server Processing 등 요인이 작용합니다.
  - 브라우저와 운영체제에서 IP 캐시를 접근하는데 걸리는 시간의 영향도 받습니다.
  - DNS로 IP를 빠르게 Resolve할 수 있어야 합니다.
  - TCP 레이어에서 연결을 열고 전달하고 닫는 성능도 좌우합니다.
  - 서버가 요청을 받으면 처리를 해야 합니다. 서버가 처리하는 성능도 중요합니다. 예를 들어 서버가 요청을 받아 다른 서버에 데이터를 요청하고 응답받아 html 페이지를 렌더링하면 TTFB가 느려질 수 있습니다.
  - 800ms 미만을 권장합니다.
  - SPA로 프론트엔드를 구현했을 경우 TTFB가 아주 중요합니다. 자바스크립트를 받아 페이지로딩을 처리하는 시간도 있기 때문에 중요합니다.
  - Server-Timing을 통해 요청응답 사이클을 측정해볼 수 있습니다. 하지만 이것은 더 정확히 latency(지연시간)를 측정하는 것입니다.
  - 모니터링 서비스를 통해서 특정해보는 것이 더 적합할 수 있습니다.
  - 성능 개선은 백엔드 기술이 다양한 만큼 각각 기술을 활용해서 적당히 문제를 해결할 수 있습니다.
  - 호스트 제공자의 환경을 잘 파악하는 것부터 시작합니다. 정적 파일 위주고 트레픽이 작으면 큰 문제는 안 될 것입니다. 하지만 동적이고 서버와 다양한 통신을 해야하면 문제가 될 수 있습니다. 일반적으로 공유호스팅한 서버가 독립적으로 호스팅한 서버 보다 느릴 것입니다. 파악해볼 만한 것들은 다음입니다.
    - 인스턴스의 메모리 할당
    - 제공자의 유지보수 상태(최신으로 유지하는가?)
    - 인스턴스의 커스터마이징할 수 있는 정도
    - https://ismyhostfastyet.com/에서 호스팅 비교도 가능합니다.
  - CDN을 활용해보는 것도 전략입니다.
    - 여러 엣지에서 캐싱하고 응답하기 때문에 성능개선하는 방법 중 하나입니다.
- 여러 페이지의 리다이렉션을 자제하도록 합니다. 특히 같은 origin 리다이렉트를 덜하는데 집중하도록 합니다.
- 마크업은 브라우저로 스트리밍합니다. 브라우저는 마크업처리에 최적화 되었습니다.
- 서비스 워커를 활용해봅니다.
- 브라우저와 서버 사이 프록시 역할로 지연시간을 단축시킬 수 있습니다.
- 103 힌트적용도 방법입니다.

참고.

[Optimize Time to First Byte](https://web.dev/optimize-ttfb/)

## 이더넷은 무엇인가?

- 이더넷은 컴퓨터 네트워크 기술 중 하나입니다. 꽤 연식이 있어서 LAN단위로 케이블을 이용해 통신합니다. 1970년대에 발명 되었습니다.
- 같은 네트워크에서 MAC 주소 즉 기계의 고유한 주소를 활용해 통신합니다. 또 통신의 충돌을 구분하기 위해서도 MAC 주소를 활용합니다.
- TCP/IP를 사용하는 인터넷도 여러 이더넷으로 만들어진 것입니다. 마치 교통과 도로의 관계와 비슷합니다.

## http가 무엇인지 어떻게 동작하는지

- http는 하이퍼 텍스트 트지션을 위한 프로토콜입니다. 먼저 하이퍼텍스트는 주로 a태그처럼 하이퍼 링크로 어떤 페이지의 요청과 접근을 의미합니다. 이 하이퍼 링크로 특정 페이지와 리소스를 서버에게 요청하는 것이 전형적입니다. 하지만 http는 꼭 HTML, CSS, 이미지 같은 정적 자원만 통신하지 않습니다. 서버가 데이터를 읽거거나 변형을 요청할 수 있습니다.
- http는 URL로 서버에 요청을 보내는 일렬의 과정입니다. URL은 특정서버의 특정 리소스를 접근하는 주소입니다. 가장 먼저 URL은 인간이 읽기 편하도록 만들어진 문자이기도 합니다. 이 URL을 그대로 요청을 알 수 있는 것은 아닙니다. 먼저 URL로 IP를 먼저 알아내야 합니다. IP를 알아낼 때까지 캐시히트가 발생할 때까지 다음 과정을 따릅니다. IP를 알아내는 과정은 먼저 브라우저부터 출발합니다. 브라우저에 IP가 캐싱이 되어 있는지 확인합니다. 없으면 운영체제에 있는지 확인합니다. 없으면 DNS 서버로 요청을 보냅니다. DNS 서버도 특정 위계와 동작방식이 있습니다. 지금은 대답하기 어렵습니다. 하지만 DNS 서버로 요청을 보내면 DNS 서버가 다른 DNS 서버로 요청을 보내고 찾을 때까지 연쇄적으로 DNS서버에 요청을 보냅니다. 결국 DNS 서버로 IP를 알아내게 되면 접근해야 하는 서버를 알아내게 된 것입니다. IP로 찾는 서버에 요청을 보낼 때 TCP 핸드쉐이크로 열고 핵심 데이터를 주고 받고 연결을 닫는 순서입니다. TCP 핸드 쉐이크 절차는 패킷 손실이 발생하지 않게 만들기 위한 일렬의 절차입니다. 클라이언트는 난수를 보내고 1을 더해 응답하고 또 서버가 난수를 보냅니다. 클라이언트는 서버가 보낸 난수에 1을 더해 응답하면 서버와 클라이언트가 보기에 통신 상태가 괜찮다고 판단하고 payload를 전달합니다. payload 전달 이후 keep-alive 설정이 아니라면 TCP 핸드 쉐이크를 진행하는데 이번에는 이동이 4번입니다. 클라이언트가 닫는 요청, 서버의 응답, 서버가 닫는 요청, 클라이언트의 닫는 응답입니다. 이렇게 payload를 받으면 브라우저는 자원마다 적절하게 처리합니다. HTML 파일을 받았을 경우 렌더링을 처리합니다.

답변일자: 2023.04.26.

## HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?

- HTTP/1.1과 HTTP/2.0의 가장 큰 차이는 HOL 블러킹 문제의 해결여부입니다.
- 먼저 HTTP/1.1은 클라이언트마다 독립적으로 요청과 응답을 할 수 있습니다. 하지만 같은 클라이언트가 동일하면 요청을 처리할 때까지 그 이후에 들어오는 요청을 처리할 수 없습니다. 이것을 보고 해드오브라인(HOL) 블러킹 문제라고 합니다. HTTP/1.1은 HTTP/1.0 보다 많은 문제를 풀었어도 이런 문제는 여전히 존하게 됩니다.
- HTTP/2.0은 스트림으로 처리해서 해드오브 라인 블러킹 문제를 7부터 5까지 어플리케이션 계층에서 해결해줍니다. 여전히 전송하는 4계층은 문제를 해결할 수 없었습니다.
- 또 HTTP/2.0 push 기능도 추가 되었습니다. 클라이언트의 polling 없이 서버가 데이터의 갱신을 클라이언트에게 얼려줄 수 있게 되었습니다.

### 왜 HTTP/2.0의 스트리밍이 어플리케이션 계층인 7계층부터 5계층까지 HOL 문제를 해결해준다는 의미는 무엇인가?

- 스트리밍이 해드오브라인 블러킹 문제를 해결해주는 것은 스트리밍이 독립적인 전송의 단위가 되었기 때문에 해결할 수 있었습니다. 하나의 스트림이 다른 스트림보다 느려도 무관하게 전송할 수 있게 되었습니다.
- 요청과 응답이 패킷에서 어플리케이션 단계로 들어왔을 때 순서가 무관해지는 것뿐입니다.

#### 스트리밍이 어플리케이션 계층에서 순서가 무관해진다는 의미는 무엇인가?

- 패킷에서 어플리케이션 계층에서 처리할 데이터가 됩니다.
- 전송계층에서 패킷을 받으면 디멀티플렉서로 스트림을 데이터로 바꿉니다.
- 어플리케이션 계층에서는 정확한 표준이 없습니다. 하지만 데이터를 받은 서버가 동시성, 병렬처리를 할지는 마음대로 프로그래머의 설계의도와 재량의 문제입니다.

### 왜 HTTP/2.0에서 여전히 4계층에서 HOL 블러킹 문제를 해결할 수 없었는가?

- 스트림을 결국 전송계층에서는 패킷으로 순서대로 전송해야 합니다.
- 하지만 이 패킷 중 손실이 발생하면 다른 스트림들이 지연됩니다.
- HTTP/2.0 스트림이 한줄입니다. 그리고 이 한줄인 스트림이 여러 줄이 되도록 제어할 수 없습니다. 또 설계도 그렇게 되어 있지 않습니다. 각각의 스트림에 우선순위만 부여할 수 있기만 가능합니다.

---

[HTTP/1 to HTTP/2 to HTTP/3](https://www.youtube.com/watch?v=a-sBfyiXysI)

http는 90년대부터 존재했습니다. 1 -> 1.1 -> 2 -> 3 버전 순서입니다.

- 1은 1996에 만들어졌습니다.
  - 모든 서버요청은 별도의 TCP 연결이 필요합니다.
- 1.1은 1997에 keep-alive 컨텍션을 유지합니다.
  - 하나 이상의 요청에 연결을 재사용할 수 있도록 합니다.
  - 지연시간을 늘리는 TCP 3-way 핸드 쉐이크를 안하기 때문에 좋습니다.
  - http 파이프라이닝도 추가되어 있습니다. 클라이언트에게 여러 응답을 동시에 보낼 수 있게 됩니다. 응답을 순서대로 올바르게 합니다.
  - http 파이프라이닝은 해드오브라인(HOL) 블러킹 문제가 있습니다.
    - 이것은 이전 요청을 처리할 때까지 다음 요청을 처리하지 못하는 문제입니다.
  - 성능을 유지하기 위해서 브라우저가 같은 서버에 TCP 연결을 저장합니다.
- 2는 2015년에 소개되었습니다.
  - http 스트림을 처리할 수 있습니다.
  - 한번의 TCP 연결 이후 독립적인 스트리밍을 할 수 있게 됩니다.
  - HOL 블러킹 문제는 어플리케이션계층(7 ~ 5)까지는 해결되었습니다. 하지만 전송계층(4)에서는 여전히 문제가 됩나다.
  - http는 push 기능도 추가되었습니다. 서버가 클라이언트가 새로운 데이터 갱신을 폴링 없이 보낼 수 있게 되었습니다.
- 3는 2020년에 초안이 작성되었습니다. 2022년 6월에 게시되었습니다. QUIC이라는 프로토콜을 활용합니다. TCP 대 신에 UDP 기반 프로토콜로 구현합니다. 스트림을 일급 시민으로 처리합니다. 추가 핸드 쉐이크가 없습니다.
  - QUIC은 스트림을 독립적으로 처리합니다. 대부분의 패킷 손실이 다른 스트림에 영향을 안줍니다.
    - 이 동작원리로 HOL 블로킹 문제를 해결합니다.
  - QUIC은 모바일 집약적인 인터넷을 위해 만들어졌습니다.
  - TCP는 다른 다른 네트워크로 이동이 느립니다.
  - QUIC은 연결 ID라는 개념으로 구현합니다. 여러 연결을 IP 주소와 네트워크 인터페이스 사이 빠르고 안정적이게 전환할 수 있게 해줍니다.
  - HTTP3는 최근에 추가되었어도 25% 비중이나 차지합니다.

[[10분 테코톡] 🧃쿨라임의 HTTP/1.1, HTTP/2, 그리고 QUIC](https://www.youtube.com/watch?v=xcrjamphIp4)

# keep-alive Connection과 Persistent Connection은 어떻게 다른가?

- keep-alive Connection은...
- Persistent Connection은...
- 이전에 TCP 연결과정을 또 처리하는 것을 아낀다는 점이 같습니다.
- TCP 통신과정으로 TCP 3-way 핸드쉐이크로 열고 TCP 4-way 핸드쉐이크 닫고 또 패킷의 유실여부를 판단해야 합니다.

---

[HTTP/1.x의 커넥션 관리](https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x)

[HTTP 지속적 연결 상태](https://ko.wikipedia.org/wiki/HTTP_%EC%A7%80%EC%86%8D%EC%A0%81_%EC%97%B0%EA%B2%B0_%EC%83%81%ED%83%9C)

# 검색창에 구글이라고 검색하면 어떻게 되나요?

```txt
https://naver.com을 주소창에 입력했을 때 일어나는 과정에 대해 아는 만큼 설명해주실 수 있을까요?
```

답변일자: 2023.03.20.

브라우저는 URL 정보를 갖고 IP를 정보를 얻어야 합니다. 제일 먼저 브라우저의 캐시를 확인하고 캐시 미스가 발생하면 운영체제에 캐시된 정보를 찾습니다. 운영체제도 캐시 미스가 발생하면 인터넷 쿼리 요청을 보냅니다. 제일먼저 DNS 서버는 요청을 받으면 DNS lookup으로 도메인에 해당하는 IP있는지 확인합니다. 캐시미스가 발생하면 다른 DNS 서버로 캐시히트로 Resolve가 발생할 때까지 요청을 연쇄적으로 보냅니다. 캐시히트가 발생하고 브라우저가 IP 정보를 갖으면 브라우저는 해당하는 IP 주소의 서버와 TCP 통신을 연결하게 됩니다. 연결하기 위해 몇 회 왕복하는 과정을 보고 TCP 핸드 쉐이크라고 부릅니다. TCP로 연결에 성공하면 클라이언트는 서버로 http 요청을 보내게 됩니다. 여기서 https로 요청을 보내게 되면 보안을 추가 단계들이 생깁니다. 브라우저는 리소스를 응답받고 처리하는데 자바스크립트 번들이나 이미지처럼 추가 리소스는 이 과정을 반복합니다.

답변일자: 2023.03.19.

브라우저는 엔진은 요청을 보내게 됩니다. 인터넷 선 혹은 와이파이로 신호를 보냅니다. 와이파이 혹은 인터넷 선은 인터넷 제공 사업자의 망을 통해 DNS 서버를 접근합니다. DNS는 도메인을 확인하고 IP로 변환하는 서버입니다. 또 DNS 서버는 자주 오는 요청을 캐싱하고 캐시힛이면 응답을 합니다. 하지만 캐시미스가 되면 다음 DNS 서버로 접근합니다. 계속 캐시미스가 발생하면 IP에 해당하는 서버에 도착하게 됩니다. 요청을 받은 서버는 요청 내용을 확인하고 클라이언트 IP로 응답을 보냅니다.

[What happens when you type a URL into your browser?](https://www.youtube.com/watch?v=AlkDbnbv7dk)

http 요청과 응답과정입니다.

먼저 사용자가 브라우저에 입력한 것은 URL입니다. URL은 Universal Resource Locator의 약어입니다. 크게 4부분으로 나눌 수 있습니다.

프로토콜 혹은 스키마입니다. http, https가 존재합니다. https는 연결시 보안됩니다. 다음은 도메인입니다. 세번째 부분은 path이고 네번째 부분은 Resource입니다. 이 관계는 파일시스템의 디렉토리와 유사합니다.

브라우저는 서버를 접근하는 법을 알아야 합니다. 이 이 과정은 DNS look업의 과정을 거칩니다. DNS는 도메인 네임 시스템의 약어입니다. 인터넷의 전화번호부와 같습니다. 도메인을 IP와 짝으로 확인합니다. DNS만 따로 다뤄야 할 서비스가 될 정도로 나중에 다룹니다. DNS lookup은 최대한 속도를 높이기 위해 캐싱이 많이 되어 있습니다. 먼저 브라우저도 짧은 시간동안 캐싱을 합니다. 캐시미스가 발생하면 운영체제에서 저장하고 있는지 접근합니다. 운영체제도 캐시가 또 있습니다. 운영체제도 없으면 인터넷으로 쿼리 요청을 보냅니다. DNS Resolver에 요청을 보내게 됩니다. 해당하는 IP를 찾을 때까지 연쇄적으로 요청을 보냅니다. DNS 인프라의 여러 서버들과 상호작용하고 접근하는 과정입니다. 접근하는 DNS 마다 응답을 캐싱하게 됩니다. 결국 브라우저는 DNS를 통해 IP 주소를 얻게 됩니다. 다음은 브라우저는 해당하는 서버와 TCP 통신을 연결합니다. TCP 통신을 연결할 때는 필요한 핸드쉐이크가 있습니다. 몇회의 네트워크 왕복이 필요합니다. 로딩 시간을 빠르게 하기 위해 현대 브라우저들은 keep alive connection을 활용합니다. 이미 서버랑 설정되었던 TCP 연결을 최대한 재사용하는 것입니다. 알아야할 것은 https는 TCP 연결을 하는 단계가 늘어납니다. SSL/TLS 핸드 쉐이크 과정이 필요합니다. 암호화된 연결을 브라우저와 서버 사이 만들어내기 위한 핸드 쉐이크 연산비용이 비쌉니다.

브라우저는 SSL 세션 재개를 활용해서 비용절약에 활용합니다. 마지막으로 브라우저는 연결 TCP 연결이 된 서버에 HTTP 요청을 보내게 됩니다. HTTP 자체는 비교적 단순한 프로토콜입니다.

서버는 요청을 처리하고 응답을 보냅니다.

브라우저는 응답을 받고 HTTP로 받은 리소스를 처리 및 랜더링합니다. 가끔은 추가로 처리할 리소스들이 있습니다. 자바스크립트 번들 및 이미지 같은 것들입니다. 남은 리소스를 얻기 위해 브라우저는 이 과정을 또 반복하게 됩니다.

---

[Everything You Need to Know About DNS (Domain Name System)](https://www.youtube.com/watch?v=27r4Bzuj5NQ)

DNS는 인터넷의 디렉토리입니다. 사람이 읽이 편한 네이버를 기계가 읽기 편한 IP 주소로 변환합니다. DNS 서버는 각각 다른 위계를 갖고 있습니다.

# 인터넷은 무엇인가?

답변일자: 2023.04.03.

- 인터넷은 인류가 갖은 가장 큰 규모의 네트워크를 말합니다. 전세계 사람들이 다양한 디바이스로 연결하여 정보를 주고 받을 수 있습니다.
- 인터넷은 다양한 프로토콜로 정보를 주고 받을 수 있지만 가장 흔히 사용하는 프로토콜이 TCP/IP입니다.
- 인터넷은 탑다운으로 접근하면 여러 LAN과 WAN의 상호연결입니다.
  - LAN(Local Area Network)는 건물, 캠퍼스 단위의 컴퓨터 네트워크를 말합니다.
  - WAN(Wide Area Network)는 도시 및 국가 단위의 컴퓨터 네트워크를 말합니다.
- 여러 네트워크를 연결한 관계라 명확한 통제하는 주체가 없습니다. LAN과 WAN를 통제하는 개인, 기업, 국가들만 존재합니다.

## 네트워크란 무엇이고 인터넷, LAN, WAN 이외에 다른 네트워크는 무엇이 존재하는가?

네트워크란 2대 이상의 컴퓨터의 연결을 말합니다.

MAN, 블루투스 네트워크, 셀룰러 네트워크

### LAN과 WAN의 차이는 무엇인가?

- LAN(Local Area Network)와 WAN(Wide Area Network)의 차이는 규모입니다.
  - LAN은 건물, 캠퍼스 단위입니다.
  - WAN은 건물과 캠퍼스가 연결될 수 있도록 도시와 국가 단위입니다.

## 프로토콜이란 무엇인가?

# OSI 7계층에 대해서 설명해주세요.

OSI 7계층은 TCP/IP의 세분화된 것입니다. 각 계층의 역할을 이해할 수 있습니다. 각 계층의 역할 파악하면 문제를 더 쉽게 파악하는 것은 물론 다른 네트워크 및 클라우드 서비스 제공자와 커뮤니케이션하는 것도 쉬워집니다. OSI 7계층은 응용, 표현, 세션, 전송, 네트워크, 데이터 링크, 물리 계층으로 구분합니다. 물리 계층은 raw bit를 전기 신호로 전달하는 계층입니다. raw bit를 전기 신호로 인코딩과 디코딩합니다. 데이터 링크 계층에서는 hop을 위해 MAC Header로 출처와 목적지를 담고 frame을 캡슐화하고 전달합니다. 목적지는 다음 hop이고 hop마다 출처와 목적지가 갱신됩니다. MAC 주소는 기계의 주민등록 번호처럼 기계가 갖는 고유한 번호입니다. 네트워크 계층은 IP Header에 출처 IP와 도착지 IP를 담고 패킷으로 캡슐화하고 전달합니다. 여기서 IP는 비유적으로 전입신고한 주소에 해당합니다. MAC 주소는 기계마다 고유하지만 IP 주소는 기계를 이동하면 이사처럼 갱신됩니다. 물론 DHCP으로 설정되어 있을 때만 해당합니다. 전송 계층은 TCP/UDP로 TCP Header 혹은 UDP Header를 추가하고 세그먼트로 캡슐화하고 전달합니다. 출처의 포트, 목적지의 포트, 패킷 시퀀스 번호를 담습니다. 또 로드 벨런싱도 처리하게 하는 경우도 있습니다. 세션 계층은 SSH, TLS같은 통신방식과 통신여부 처리합니다. 표현계층은 인디코딩과 디코딩을 처리하고 인코딩과 디코딩을 위한 바이너리 데이터를 전달합니다. 응용계층에서는 프로그램에 해당하는 프로토콜을 주고 받게 되는 계층으로 사용자의 최초 정보가 해당합니다.

응용, 표현, 세션 계층은 사용자를 지원하는 계층입니다. 네트워크, 데이터 링크, 물리 계층은 네트워크를 지원 계층입니다. 중간 전송 계층은 사용자와 네트워크 지원 계층을 연결합니다.

---

[What is OSI Model | Real World Examples](https://www.youtube.com/watch?v=0y6FtKsg6J4)

인터넷은 어떻게 데이터를 보내고 OSI 7계층과 무슨 연관이 있는가? 그리고 TCP/IP는 어떻게 중간에 들어가는가? OSI 7계층은 네트워크를 다루는 표준 모델입니다. 2개의 기기의 통신과정을 7단계로 추상화한 것입니다. 1계층은 물리 계층입니다. 바이너라 같은 raw 데이터를 전달합니다. 2계층은 데이터 링크 계층입니다. raw 데이터를 받아 MAC Header, IP Header, TCP Header, HTTP Header, Data 같은 프레임으로 변환합니다. 프레임이 올바른 곳으로 전달되도록 보증합니다. 이 계층에 이더넷이 위치합니다. 3계층은 네트워크 계층입니다. 다양한 네트워크에 따라 데이터 프레임을 라우팅하는 책임을 집니다. 이부분의 TCP/IP 중 IP 부분이 여기 해당합니다. 4계층은 전송 계층입니다. 2개 Node 사이 E2E 커뮤니케이션을 보장합니다. 이 계층에 TCP/UDP가 속합니다. TCP 통신은 2 기계사이 E2E 통신을 신뢰할 수 있게 해줍니다. 데이터를 전송할 때 세그먼트로 작게 쪼개서 전달합니다. 세그먼트 각각 독립적으로 전달합니다. 또 세그먼트마다 고유한 시퀀스번호도 붙입니다. 받은 쪽은 전달받은 데이터의 순서를 올바르게 정리하기 위해 활용합니다. TCP는 또 전송 중에 데이터에 손상이 있었는지 에러 체크도 처리합니다. UDP는 전송계층에서 사용하는 또 다른 프로토콜입니다. TCP와 비슷하지만 더 단순하고 더 빠릅니다. TCP랑 다르게 높은 수준의 에러체킹과 신뢰성 검증을 하지 않습니다. 단순히 하나의 기계에서 다른 기계로 패킷을 전달해 줍니다. 전달 받은 쪽이 올바르게 받았는지 검토하는 책임만 갖고 있습니다. 에러가 있으면 받는 쪽이 단순히 패킷을 버리기만 합니다. 남은 계층은 세션, 프레젠테이션, 어플리케이션 계층입니다. 여기서 OSI 모델의 유용성을 실무에서 잃는 부분입니다. 더무 디테일하게 정해져있지만 현실을 잘 반영하지 않습니다. 일반적으로 하나의 계층으로 합치는 경우가 많습니다. 마지막 7계층 어플리케이션 프로토콜 계층으로만 취급하는 것이 현실적입니다.

사용자 네트워크로 HTTP요청을 보내면 HTTP Header가 어플리케이션 계층에서 데이터의 Header에 추가됩니다. 그 후 TCP Header가 4계층에서 추가됩니다. TCP Header는 TCP 세그먼트로 캡슐화되어 있습니다. TCP Header 속에는 출처 포트, 목적지 포트, 시퀀스 번호를 저장합니다. 이 세그먼트들은 3계층 네트워크 계층에서 IP Header로 캡슐화합니다. IP Header는 출처와 목적지 IP를 담습니다. MAC Header는 2계층 데이터 링크 계층에서 추가됩니다. 출처와 목적지 MAC 주소를 담습니다. MAC 주소는 현실세계에서 약간 미묘하게 다릅니다. 사실 출처와 목적지 MAC 주소를 담지 않습니다. 다음 hop을 하게될 MAC 주소입니다. 캡슐화된 프레임은 raw bit로 1계층 물리계층에서 전송이 됩니다. 응답을 받은 기계는 이 순서의 역순으로 처리합니다.

OSI 계층은 네트워크를 하나의 방향으로 생각할 수 있는 모형입니다. 주목적은 교육용입니다. 클라우드 및 네트워크 서비스 제공자들이 어느 단계에 서비스를 제공하는지 간단하게 알려줄 수 있는 모형입니다. 예를 들어 클라우드 로드 벨런서는 2개로 분류할 수 있습니다. L4, L7이 있는 L7은 HTTP, HTTPS 같은 어플리케이션 계층에서 로드 벨런싱을 처리한다는 의미로 보면 됩니다. L4는 TCP 프로콜에서 로드 벨런싱을 처리한다는 의미입니다.

- 각 계층 장비는 아래 레이어를 포함하는 구조

  - 1계층(L1) 장비는 1계층 기능만 가진 장비이다. (인코더/디코더)
  - 2계층(L2) 장비는 1~2계층 기능을 모두 가진 장비이다. (L2스위치 / MAC주소)
  - 3계층(L3) 장비는 1~3계층 기능을 모두 가진 장비이다. (라우터 = 중계노드 / IP주소)
  - 4계층(L4) 장비는 1~4계층 기능을 모두 가진 장비이다. (L4로드밸런서 / 포트)
  - 7계층(L5) 장비는 1~7계층 기능을 모두 가진 장비이다. (컴퓨터, 핸드폰)

- 프로토콜 서비스 별 포트 번호
  - 웹 서비스 **(HTTP, HTTPS) : 80, 443**
  - 파일 전송 서비스**(FTP): 21**
  - 이메일 서비스**(SMT, POP3): 25, 110**
  - 도메인 서비스**(DNS): 53**

1. 📡 물리 계층
   - 🚦규칙 : Hub, Repeater
   - 🧩단위 : 비트 (Bit)
2. ⛓️ 데이터 링크 계층
   - 🚦규칙 : MAC 주소
   - 🧩단위 : 프레임 (Frame)
3. 🎯 네트워크 계층
   - 🚦규칙 : IP
   - 🧩단위 : 패킷 (Packet)
4. 🔐 전송 계층
   - 🚦규칙 : TCP, UDP
   - 🧩단위 : 세그먼트(Segment)
5. ⛳️ 세션 계층
   - 🚦규칙 : OS
   - 🧩단위 : 데이터(Data)
6. 🗂️ 표현 계층
   - 🚦규칙 : JPG, MPEG
   - 🧩단위 : 데이터(Data)
7. 👩‍💻 응용 계층
   - 🚦규칙 :
     - HTTP = 웹 접근 프로토콜
     - FTP = 파일 전송 프로토콜
     - Telnet = 통신 프로토콜 (단말 접속용)
   - 🧩단위 : 데이터(Data)

![image](https://user-images.githubusercontent.com/84452145/227761621-82b86370-75da-44f0-9961-5df85342a139.png)

# 패킷의 용도와 구성은 무엇인가?

# 서버란 무엇인가?

- 공유기 : 네트워크에서 파일이나 프린터를 공유하게 해준다.
- 도메인 관리기(DNS) : 도메인 주소(naver.com)로 IP주소를 찾게 해준다.
- IP 할당기(DHCP) : 네트워크에 새로 접속한 장비에 IP주소와 네트워크 설정을 해준다.
- 시간관리기(NTP) : 네트워크상에 장비들의 시간을 알맞게 맞춰준다.
- 게이트웨이 : 여러대의 장비가 외부 네트워크에 접속하게 해준다.

# 소프트웨어 정의 네트워크(SDN)란 무엇인가?

# IP 할당기(DHCP)란 무엇인가?

# 시간관리기(NTP)란 무엇인가?

# 게이트웨이란 무엇인가?

# IP는 무엇이고 MAC 주소는 무엇이며 어떻게 다른가?

# http의 버전벌 차이를 나열하시오.

# http랑 https가 각각 다른 port 번호를 갖는 이유를 설명해주십시오.

https://johngrib.github.io/wiki/why-http-80-https-443/

포트번호를 지정할 때 당시 남았던 번호를 지정하면서 갖게 되었습니다. 특별한 의미가 있던 것은 아니었습니다.

## 포트번호를 지정하는 기관의 이름은 무엇인가?

# http, https, webRTC, ws, RTSP(실시간 스트리밍) 이외 프로토콜이 뭐가 존재하는지 알려주세요.

# RTT (Round Trip Time, 왕복 시간)란?

# TCP 3 way handshake란 무엇인지 설명해주실 수 있을까요?

TCP는 Transmission Control Protocol의 약어입니다. TCP 3-way handshake는 클라이언트와 서버사이 데이터 전송을 보장하기 위해 연결을 설정하는 과정입니다. IP는 가장 효율적인 목적지만 찾고 TCP로 순서와 전달여부를 보장하게 만드는 방식으로 통신을 합니다. 핸드쉐이크가 이루어지는 과정은 클라이언트가 보안을 위해 난수로 서버에 보냅니다. 서버는 통신이 성공했다는 것을 인식시키기 위해 ack로 1을 더하고 syn에 해당하는 난수를 함께 클라이언트에 전송합니다. 이것을 보고 syn/ack에 해당합니다. 마지막으로 ack를 받은 클라이언트는 1을 더하고 서버에 전송합니다.

[What is the TCP 3-Way Handshake and Why Backend Engineers should understand it](https://www.youtube.com/watch?v=bW_BILl7n0Y)

# https 보안절차

[SSL, TLS, HTTPS Explained](https://www.youtube.com/watch?v=j9QmMEWmcfo)

http로 비밀번호, 신용카드 정보를 전송하면 평서문으로 전송됩니다. https는 암호화된 문자로 전송됩니다. 중간에 탈취되어도 해커는 정보를 복호화 해야합니다.

브라우저는 TCP 통신을 구축합니다.

## SSL, TSL가 무엇인가?

# TCP 와 UDP 를 비교하여 설명해주실 수 있을까요?

> UDP(User Datagram Protocol)와 TCP(Transmission Control Protocol)는 인터넷 프로토콜 스위트(Internet Protocol Suite)의 일부로, 컴퓨터 네트워크에서 데이터 전송을 위해 사용되는 두 가지 프로토콜입니다.
>
> UDP는 신뢰성이 낮은 데이터그램 데이터 전송 프로토콜입니다. UDP는 패킷의 크기가 작고, 패킷 로스가 발생하더라도 재전송이 이루어지지 않기 때문에, 전송 속도가 빠르고 오버헤드가 적습니다. 그러나, UDP는 데이터를 전송하기 전에 연결 설정 절차가 없기 때문에, 데이터를 보내고 받는 순서가 보장되지 않으며, 데이터 무결성이 보장되지 않습니다. 그렇기 때문에, 비디오 스트리밍, DNS 조회와 같이 속도가 빠른 데이터 전송이 필요한 경우에 주로 사용됩니다.
>
> 반면에 TCP는 신뢰성 있는 연결 지향적인 프로토콜로, 연결 설정 및 해제 절차를 통해, 데이터 전송에 대한 신뢰성, 무결성 및 순서를 보장합니다. TCP는 패킷의 크기가 크고, 재전송이 발생하면 재전송을 수행하기 때문에 오버헤드가 UDP에 비해 큽니다. 그러나, 데이터의 전송 순서와 무결성이 보장되기 때문에, 파일 전송, 이메일 전송 등의 신뢰성이 중요한 데이터 전송에 주로 사용됩니다.
>
> 따라서, UDP와 TCP는 데이터 전송에 있어서 사용되는 프로토콜로, UDP는 빠른 전송을 중요시하는 대신 데이터 무결성을 보장하지 않고, TCP는 신뢰성이 중요한 대신, 느리지만 데이터 무결성과 전송 순서를 보장합니다.
>
> - chatGPT

---

UDP와 TCP모두 네트워크 데이터 중 페킷을 전달하는 프로토콜입니다. TCP의 경우 3-way-handshake로 연결 검증 통신 4-way-handshake로 연결을 종료하는 프로토콜입니다. 즉, 연결 상태를 확인하고 패킷의 순서와 전송여부를 신뢰할 수 있습니다. 이런 프로토콜로 무결성을 보장할 수 있습니다. 하지만 속도가 느리고 오버헤드가 발생합니다. 그래서 신뢰가 중요한 이메일같은 통신에 많이 활용합니다. 반면 UDP는 연결 설정과 해제 과정이 없습니다. 패킷에 대한 순서 유실이 발생해도 재전송하지 않습니다. 그래서 무결성을 보장할 수 없습니다. 이런 이유로 신뢰가 중요하지 않고 속도가 중요한 경우인 비디오 스트리밍 혹은 DNS 조회에 많이 활용합니다.

# HTTP에 대해 설명하고, 알고있다면 HTTP 메세지 구조에 대해 더 자세히 설명해주세요

HTTP는 hypertext transfer protocol의 약어입니다. hypertext는 웹페이지를 연결하는 링크를 뜻합니다. transfer는 전화 같은 것을 연결하다는 의미인데 인터넷의 경우 특정 페이지를 의미합니다. protocol은 절차를 뜻하는데 인터넷 통신의 다양한 절차를 의미합니다. HTTP는 특정 페이지 같은 리소스를 서버에게 요청을 보내고 그 특정 페이지를 서버로 부터 받는 응답입니다.

HTTP의 메시지 구조는 다음과 같습니다. 먼저 요청의 경우 요청라인, 해더, 공백라인, 요청 메시지로 구성됩니다. 요청라인에는 메서드, request-target, HTTP-version이 있습니다. 요청 메시지 해더의 경우 Host와 url을 담습니다. 반면 응답의 경우 상태라인, 해더, 공백라인, 응답 메시지고 구성됩니다. 상태라인의 경우 HTTP-version, status-code, reason-phrase으로 구성됩니다. 응답 메시지 해더의 경우 Content-type, Content-Length 같은 데이터들이 위치합니다. 나머지 공백라인은 요청과 응답 모두 공백에 해당합니다. 또 요청 응답 메시지의 경우 그 해당하는 리소스입니다.

---

# 기타

Polling

Polling은 http 프로토콜이 실시간성 서비스를 만들 때 이해해야 하는 개념입니다.

http는 클라이언트요청 서버의 응답을 받으면 통신은 끝납니다. **폴링(Polling)**은 브라우저가 **일정 주기로 계속 요청을 보내는 것**입니다. 실시간으로 바뀐 데이터를 받아올 수 없습니다. 또 짧게 요청을 보내면 서버에 부하, 병목 등 비용이 발생합니다. 그래서 만약 요청응답 주기가 길어도 괜찮으면 **롱 폴링(Long Polling)**도 전략입니다. 요청을 보내고 서버가 응답을 바로 보내지 않습니다. 데이터의 변동이 있다면 바로 응답합니다. 데이터 변동이 없는 동안 서버는 응답을 일정 시간동안 지연합니다.

유저가 만약에 로그인을 하면 클라이언트는 로그인 요청을 서버로 보내게 된 것입니다. 서버는 클라이언트의 데이터를 확인하고 적절한 응답을 할 것입니다. 해커면 거부하고 실제 사용자이면 로그인은 승인할 것입니다. 클라이언트가 또 채팅방을 접속하면 채팅방 데이터를 요청하게 됩니다. 서버가 사용자의 접속상태를 계속 추적할 것처럼 생각하지만 실제로는 아닙니다. http는 요청응답 라이프사이클이 끝나면 통신은 끝납니다. 통신을 끝내야 서버 부하를 막을 수 있습니다. 서버는 로그인 상태의 유저는 서버는 사용자의 로그인 여부를 사실 모릅니다. 이것을 보고 무상태성이라고 합니다.

서버는 대부분의 경우 요청을 보내야지만 응답할 수 있습니다.

폴링으로 처리할 수 밖에 없는 이유는 클라이언트가 서버로 요청만 가능하기 때문입니다. 서버가 먼저 클라이언트에 통신할 수 없습니다. TCP, 핸드쉐이크 절차를 알아보도록 합니다.

이런 지식은 네트워크의 기본 중에 기본 지식입니다.

실제 실시간 채팅을 구현할 것이라면 Socket을 알아보도록 합니다.

서버랑 통신을 할 때 사용하는 API는 RestAPI입니다. HTTP는 웹에서 정보를 주고 받을 수 있게 해주는 프로토콜입니다.

클라이언트에서 로그인을 1번 하면 서버는 아이디, 비밀번호, 토큰을 확인하고 로그인 승인을 합니다. 마이페이지로 들어가면 개인정보 요청을 보내면 개인정보 응답을 해줍니다. 서버는 클라이언트는 사실 본인이 본인인지 모릅니다. http 요청은 단발요청입니다. 로그인을 하고나면 새로운 요청으로 마이페이지 요청을 보내게 된 것입니다. 서버는 이전에 로그인 여부를 모릅니다. 이것을 보고 무상태성이라고 합니다. 클라이언트가 본인이라는 것을 인증하기 위해 필요한 것은 토큰입니다. 클라이언트가 최초 로그인에 토큰을 지급해줍니다. 클라이언트 기계에 저장합니다. 그리고 개인정보 요청을 보낼 때마다 header에 메타데이터로 본인이라고 증명할 정보를 보내는 것입니다.

OAuth 2.0입니다. 외부서비스의 인증 및 권한부여를 관리하는 프레임워크입니다. Open Authentication, Open Authorization를 합친개념입니다.

클라이언트와 서버에서 로그인(인증)하면 access_token을 지급합니다. 앞으로 클라이언트는 access_token을 통해 인증할 수 있습니다.

구글은 유저 정보, 로그인 검증을 해줍니다. 구글은 자원서버이자 권한 서버의 역할을 모두합니다. 자원 소유자는 로그인 정보 소유자입니다. 클라이언트가 로그인을 하면 클라이언트인 자원 소유자가 자원서버에 요청을 보낸 것입니다.

클라이언트는 access_token을 갖고 있으면 유저정보를 제공합니다.

토큰을 보고 서버는 계속 본인인지 알 수 있습니다. 토큰은 사실 유저가 넘긴 아이디 비밀번호를 암호화한 것입니다. 그래서 고유하고 각자 다릅니다.

JWT는 데이터 JSON 형식인 토큰입니다.

생김새 : [header].[payload(내용)].[signature(서명)]

- header는 암화방식 정보가 들어가있습니다.
- payload: 토큰에 담을 정보가 name: value 쌍으로 들어갑니다.
- signature: 서명 정보입니다. secret key를 포함해서 header와 payload 정보가 암호화 되어 들어갑니다.

이것은 클라이언트가 서버에 로그인 요청을 하면 서버는 JWT 토큰을 만들어줄것입니다(가정입니다). 클라이언트는 토큰을 받고 로컬 머신에 저장합니다.

JWT vs OAuth는 말티즈와 아파치 헬리콥터를 비교하려는 것과 비슷합다. 하나는 인증방식이고 다른 하나는 암호데이터 입니다.

약간의 복습니다. http는 서버랑 클라이언트랑 통신하는 절차입니다. 최초 로그인을 요청하면 서버는 access_token을 만들어서 클라이언트에게 제공합니다. 서버는 절대 클라이언트의 로그인 상태를 계속 추적하지 않습니다. 적어도 웹에서는 그렇습니다. 클라이언트는 토큰을 통해서 요청을 보내는 것으로 무상태성으로 통신할 수 있게 됩니다.

웹 저장소입니다. 개발자 도구 > Application > Storage를 보면 됩니다. 여기서 Cookies입니다. Cook는 document 객체가 갖고 있는 속성값입니다.

```js
// key는 MY_COOKIE, value는 here,
document.cookie = 'MY_COOKIE=here;';
```

브라우저 콘솔에 이렇게 조작할 수 있습니다. name, value를 넣을 수 있습니다.

로그인할 때 삽입하고 로그아웃 할 때 삭제해야 합니다. 삭제를 만료일로 삭제할 수 있습니다.

```js
const expires = new Date('2020-12-12').toUTCString();
document.cookie = 'MY_COOKIE=here; expires=' + expires;
```

이런 방식으로 만료일을 설정할 수 있습니다.

세션 스토리지는 브라우저 창을 닫으면 사라집니다. 로컬 스토리지는 브라우저 창을 닫아도 남아있습니다. 지우기 전까지 남아있습니다.

```js
// key는 MY_SESSION, value는 here인 세션을 만들어요.
sessionStorage.setItem('MY_SESSION', 'here');

// key값으로 쉽게 가져올 수 있어요 :)
sessionStorage.getItem('MY_SESSION');

// 하나만 삭제하고 싶다면, 이렇게 키를 통해 삭제합니다.
sessionStorage.removeItem('MY_SESSION');
// 몽땅 지우고 싶을 땐 clear()를 쓰면 됩니다. :)
sessionStorage.clear();
```

절대 아이디, 비밀번호 같은 정보를 넣지 말아야 하는 곳입니다.

```js
// key는 MY_LOCAL, value는 here인 데이터를 저장해요.
localStorage.setItem('MY_LOCAL', 'here');

// key값으로 쉽게 가져올 수 있어요 :)
localStorage.getItem('MY_LOCAL');

// 하나만 삭제하고 싶다면, 이렇게 키를 통해 삭제합니다.
localStorage.removeItem('MY_LOCAL');
// 몽땅 지우고 싶을 땐 clear()를 쓰면 됩니다. :)
localStorage.clear();
```

보안이 중요한 쿠키로 저장합니다. 별로 안 중요하면 로컬 스토리지에 저장합니다. 프로젝트 성향마다 다르지만 대체로 이런 방식으로 대응할 수 있습니다.
