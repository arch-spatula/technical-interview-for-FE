https://www.freecodecamp.org/news/the-this-keyword-in-javascript/

# 깊은 복사 얕은 복사

# this 가 동작하는 원리와 용법을 아는대로 설명해주세요. 평소 코드 중에서는 어떤 부분에서 가장 큰 차이가 생기나요?

`this`는 호출하는 객체에 따라 달라집니다. 자바스크립트는 프로토타입 기반 언어입니다. 모든 것이 프로토타입입니다. 모든 것이 프로타입이기 때문에 모든 함수는 사실 메서드입니다. 문법을 보면 단순히 함수를 실행한 것 같지만 전역객체의 메서드로서 실행된다는 것이 생략되어 있습니다. 그리고 이 전역 객체의 메서드로 호출 되었을 때를 주의해야 합니다.

```js
function f1() {
  return this;
}

// 브라우저
f1() === window; // true

// Node.js
f1() === global; // true
```

이 경우 생략된 전역객체의 메서드로 실행된 것입니다.

```js
function f2() {
  "use strict"; // 엄격 모드 참고
  return this;
}

f2() === undefined; // true
```

엄격 모드를 활성화하면 정상적으로 undefined를 바라보게 됩니다.

먼저 실행 컨텍스트라는 것이 있는데 함수를 호출하는 주체인 객체 따라 다르게 this를 할당하기 때문입니다. 이것을 보고 암시적 바인딩이라고 부릅니다.

```js
function foo() {
  console.log(this.age);
}

const nkh = {
  age: 30,
  foo,
};

function callbackFoo(func) {
  func();
}

callbackFoo(nkh.foo); // undefined
```

하지만 콜백으로 호출할 때 주의해야 합니다. 콜백함수는 전역객체의 메서드 즉 프로그래머에게 익숙한 함수 개념으로 호출하고 대입한 것이기 때문에 this의 바인딩을 잃습니다. 이것은 간편하게 이해하는 방법입니다. 더 자세히는 콜백함수를 대입받은 고차함수를 호출하는 주체의 문제입니다.

`this`가 할당 될 객체는 `call`, `apply`, `bind`로 제어하는 것도 가능합니다. 이것을 보고 명시적 바인딩이라고 합니다. 이런 메서드를 활용해서 DOM 조작을 하면서 얻는 유사배열객체에 배열메서드를 활용하는 것도 가능합니다.

참고로 실행 컨텍스트란 자바스크립트 코드를 실행하기 위해 제공할 환경 정보들을 모아놓은 객체입니다. 코드를 실행하는데 자바스크립트 코드가 실행하고 있는 동안의 맥락에 실행되는 방식을 좌우한다는 말입니다. this의 경우 호출하는 주체가 어느 객체인지에 따라 맥락이 결정된다는 의미입니다.

`평소 코드 중에서는 어떤 부분에서 가장 큰 차이가 생기나요?`에 대한 답의 의미를 잘 파악하기 어렵습니다. 다른 언어처럼 정의한 위치에서 this 혹은 self가 결정된 다는 것을 질문하는 것인지 모르겠습니다.

[MDN - this](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this)

[기억보다 기록을 - 자바스크립트에서 this의 규칙](https://kyounghwan01.github.io/blog/JS/JSbasic/this/#this-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC-%E1%84%80%E1%85%B2%E1%84%8E%E1%85%B5%E1%86%A8)

## 왜 엄격모드를 활성화하면 this는 undefined를 바라보게 되나요? 기술적으로 동작하는 원리를 설명해주시기 바랍니다.

es6 스펙을 정의하면서 자바스크립트를 조금더 정상적인 언어로 만들려고 힜습니다.

자바스크립트는 JIT 컴파일러 언어입니다. 컴파일 과정에서

## this 키워드는 왜 var, let, const를 사용하지 않을 수 있는가? 그리고 이 질문의 가치를 평가하라.

this는 자바스크립가 이미 정의해둔 키워드입니다.

# 이런 현상이 발생하는 이유를 설명해주시기 바랍니다.

클로저 현상을 보여주고 무슨일이 일어나고 왜 발생하나요?

```js
const arr = [];
for (var i = 0; i < 3; i++) {
  arr[i] = function () {
    return i;
  };
}

console.log(arr[0]());
console.log(arr[1]());
console.log(arr[2]());
```

위 코드에서 예상하는 출력값을 말하고 왜 그 값을 출력하는지 말하십시오.

# innerHTML이 왜 보안 취약점을 만드는지 논하십시오.

https://github.com/h5bp/Front-end-Developer-Interview-Questions

# parameter와 argument의 차이에 대해 설명해주세요.

- parameter는 번역하면 매개변수에 해당합니다. 함수가 받는 변수로 어떤 값을 대입받았을 때 함수 내에서 어떻게 처리할지 대수적으로 표현하는 변수입니다.

- argument는 번역하면 인자입니다. 함수를 호출하고 대입하는 값에 해당합니다.

https://www.youtube.com/shorts/OMIrZ8G2rBc

# 클로저란 무엇인가?

# 자바스크립트 컴파일 과정을 설명하십시오.

# 자바스크립트 아키텍처를 그려주십시오.

## 콜스택은 무엇인가?

## ECMAScript 명세에 기인한 Task Queue를 분류해주십시오.

# `__proto__`, `[[proto]]`, `prototype`에 대해 설명해주시기 바랍니다.

자바스크립트는 멀티패러다임언어이고 prototype기반 언어입니다. 모든 자바스크립트의 자료형은 Object 객체를 상속하면서 만들어졌습니다. 이런 이유로 Object의 정적메서드를 많이 사용하고 동적메서드는 거의 없습니다. 자바스크립트는 1995년에 만들어진 언어이고 프로토타입으로 상속을 구현하기 위해 prototype 속성을 활용합니다. 모든 생성자 함수는 prototype이라는 속성을 갖고 있습니다. prototype을 통해 생성한 인스턴스가 접근할 수 있고 생성자함수가 접근할 수 없는 동적메서드를 생성할 수 있습니다. 생성자함수 뒤에 prototype 속성 뒤에 메서드를 붙여서 정의하면 동적 메서드를 만들 수 있습니다. prototype은 인스턴스가 생성된 원형에 해당하는 생성자함수를 가리키도록 제어하는 속성이기 때문에 이런 방식으로 동작합니다. 또 이렇게 동작하는 이유는 es6 이전에 객체지향적인 프로그래밍이 일반적이었을 때 상속을 구현하기 위한 방법이었습니다.

## 객체(Object)에 동적메서드가 거의 없다고 했는데 거의 없다는 것의 기준은 무엇인가?

## 컨스트럭터와 생성자함수의 차이는 무엇인가?

자바스크립트가 아닌 일반 프로그래밍적인 의미에서는 동일합니다. 하지만 자바스크립트 프로그래밍에서는 의미가 다릅니다. 생성자 함수는 new 키워드로 인스턴스를 생성하는 함수를 의미합니다. 반면 컨스트럭터는 생성자함수를 호출할 때 초기화하는 함수입니다. 또 자바스크립트의 경우 상속을 제어할 때 사용합니다.

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/constructor

## 일반함수와 생성자함수의 차이는 무엇인가?

기술적인 차이는 모던 자바스크립트 튜토리얼에 의하면 없다고 합니다. 하지만 작성할 때 관례적인 차이는 존재한다고 합니다. 생성자 함수는 `new` 키워드를 붙이는 것으로 객체 생성을 표현합니다.

## 주로 prototype은 어디에 사용하는가?

주로 폴리필를 위한 라이브러리코드, 레거시코드에서 주로 볼 수 있습니다. 일부 객체지향성향이 강한 어플리케이션 코드베이스에서 접하는 경우도 존재합니다.

## 클래스와 생성자함수는 동일한가요?

동일하지 않습니다. 문법설탕으로 오해받는 경우가 많지만 내부적인 동작이 다릅니다.

https://www.youtube.com/watch?v=LPEwb5plEoU

https://ko.javascript.info/class

# 이터러블이란 무엇인가?

# 제너레이터란 무엇인가?

# ==과 ===의 이름의 이름은 무엇인가?

==은 동등 연산자입니다. ===은 엄격 동등 연산자입니다.

# Event bubbling 과 capturing 을 비교하여 설명해주실 수 있을까요?

답변일자: 2023.03.23.

DOM 이벤트에서는 3가지 흐름이 있습니다. 캡쳐링, 타깃, 버블링입니다. 이벤트 캡쳐링은 이벤트가 발생한 구체적인 DOM의 리프트리 방향으로 접근하는 과정입니다. 이벤트 타깃은 사용자가 실제로 어떤 동작의 대상이 된 태그입니다. 그리고 이벤트 버블링은 타깃에서 DOM트리의 루트로 전파되는 과정입니다.

이벤트 버블링은 거품처럼 루트인 위로 이벤트 캡쳐링은 리프 방향인 아래로 향합니다. 이벤트 캡처링은 이벤트 타깃 전이고 이벤트 버블링은 이벤트 타깃 이후입니다.

# Hoisting 이란? TDZ란?

호이스팅은 자바스크립트 분석과정에서 function 키워드 선언된 함수 식별자와 var 키워드로 정의된 식별자를 모듈 및 함수에서 정의한 위치와 무관하게 참조할 수 있는 현상을 보고 호이스팅이라고 합니다. 호이스팅을 번역하면 끌어올려지다 라는 의미를 갖고 있습니다. 이 의미는 사람이 코드를 읽을 때 특정 식별자가 상단으로 끌어올려져서 읽으면 이해가 쉽다고 소개되었기 때문에 붙은 이름입니다. 호이스팅은 위치와 무관하게 참조할 수 있기 때문에 정점이 되고 또 단점이 되기도 합니다. top-level 함수는 function 키워드를 활용하고 내부에서는 화살표함수를 권장합니다.

TDZ는 번역하면 일시적으로 죽은 공간을 의미합니다. const, let으로 선언한 변수 이전에 해당하는 변수를 호출하면 참조 에러를 돌려주는 것을 알 수 있습니다. 호이스팅 현상이 없었고 변수 선언 전에 호출하기 때문에 참조할 변수가 없어서 발생한 에러입니다. es6 문법으로 변수를 선언하기 전까지의 공간은 TDZ에 해당합니다.

https://ui.toast.com/weekly-pick/ko_20191014

# Microtask Queue 와 Macrotask Queuea 는 각각 무슨 API를 갖고 있는지 나열하십시오.

Microtask Queue:

- Promise.resolve()
- Promise.reject()
- process.nextTick() (Node.js에서만 해당)

Macrotask Queue:

- setTimeout()
- setInterval()
- setImmediate() (Node.js에서만 해당)
- requestAnimationFrame()
- I/O
- UI 렌더링 이벤트

https://www.ecma-international.org/publications-and-standards/standards/ecma-262/

[Jake Archibald: 루프 속 - JSConf.Asia](https://www.youtube.com/watch?v=cCOL7MC4Pl0)

## requestAnimationFrame가 Macrotask Queue에 포함되어 있다는 근거 무엇인가?

# NodeJS는 언제 단일 스레드이고 언제 다중 스레드입니까?

[When is NodeJS Single-Threaded and when is it Multi-Threaded?](https://www.youtube.com/watch?v=gMtchRodC2I)

# eval()은 실무적으로 언제 사용해야 하는가?

기본적인 권장 사항은 실무적으로 활용하지 말라고 합니다.

문자열을 자바스크립트코드로 변환하고 실행할 수 있는 함수입니다.

## 보안상 취약해지는 이유는 무엇인가?

# 프론트엔드 엔지니어가 보통 추구하는 프로그래밍 패러다임은 무엇이고 왜 그 프로그래밍 패러다임을 추구하는가?

프론트엔드 엔지니어는 주로 함수형 프로그래밍 패러다임을 추구합니다. 함수 컴포넌트를 사용하기 시작한 리액트의 영향도 있고 this에 대한 멘탈 오버해드도 존재합니다.

실무적으로 함수형 프로그래밍 패러다임으로 코드를 작성하면 얻을 수 있는 장점은 가독성, 가변성, 테스트 가능성입니다. 하지만 성능을 트레이드오프로 지불해야 합니다. 클라이언트 기계로 실행하고 사용성을 저해하는 것이 극단적인 것이 아니라면 상당히 괜찮은 선택입니다. 프론트엔드 엔지니어는 사용자가 접할 소프트웨어의 부분을 개발하고 많은 개발과정에 이터래이션을 거칩니다. 이터래이팅을 하면서 빠르게 PMF를 검증해야 하기 때문에 가독성과 가변성이 높으면 유리하기 때문에 선택합니다. 코드의 수명이 짧고 가변성이 높아야 하는 요구사항을 받기 때문에 함수형 프로그래밍 패러다임이 유리합니다.

국내의 대부분의 컴퓨터과학 전공자는 객체지향 프로그래밍으로 교육을 받기 때문에 이런 부분은 큰 단점이 될 수 있습니다.

# 함수형 프로그래밍에서 커링과 파이프란 무엇인가?

함수형 프로그래밍에서 커링과 파이프 전에 함수의 합성 즉 컴포지션이라는 상위 개념을 이해해야 합니다. 컴포지션은 합수를 합성하는 것입니다. 자바스크립트의 경우 함수는 일급함수 즉 함수자체를 하나의 값, 객체로 취급하고 함수자체를 함수에 대입하는 것이 가능하기 때문에 함수 합성이 가능합니다. 수학적인 개념에서 합성함수와 동일합니다.

커링은 f(a, b, c)처럼 단일 호출로 처리하는 함수를 f(a)(b)(c)와 같이 각각의 인수가 호출 가능한 프로세스로 호출된 후 병합되도록 변환하는 것입니다.

```js
import _ from "lodash";

// 커링
const add = (x, y) => x + y;
const curriedAdd = _.curry(add);
const add2 = curriedAdd(2);
console.log(add2(3)); // 5

// 파이프
const square = (x) => x * x;
const add1 = (x) => x + 1;
const squareAndAdd1 = _.flow([square, add1]);
console.log(squareAndAdd1(2)); // 5
```

[모던 자바스크립트 튜토리얼 - 커링](https://ko.javascript.info/currying-partials)

# 함수형 프로그래밍에서 모나드란 무엇인가?
