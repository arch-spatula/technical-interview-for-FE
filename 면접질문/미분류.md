# 쓰레드와 프로세스의 차이?

프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.

프로세스는 동립적이기 때문에 다른 프로세스에 문제를 일으킬 수 없습니다. 크롬은 각 탭을 독립적인 프로세스로 처리합니다.

스레드는 프로세스 속에서 실행하는 단위입니다. 최소 1개 이상의 쓰레드를 갖고 있고 이 쓰레드 이름은 메인 쓰레드라고 부릅니다. 쓰레드는 동일한 메모리 공간을 공유힉 때문에 스위칭이 없습니다.

컨텍스트 스위칭으로 여러 프로세스를 처리할 수 있습니다. 컨텍스트 스위칭은 계산비용이 비쌉니다.

[FANG Interview Question | Process vs Thread](https://www.youtube.com/watch?v=4rLW7zg21gI)

흔한 면접 질문입니다.

이 질문을 답하기 전에는 프로그램이 무엇인지 알아야 합니다. 사람들이 말하는 프로그램은 주로 실행파일입니다. 프로그램의 실행절차에 대한 코드는 디스크에 저장되어 있습니다. 프로그램을 실행하게 되면 메모리로 호출되고 프로세서가 프로세싱을 합니다. 이때 프로세스가 됩니다. 활성화된 프로세스는 프로그램을 실행하기 위한 리소스도 포괄해 지칭합니다. 이런 리소스들은 보통 운영체제로 제어됩니다. 예를 들면 프로세스 레지스터, 프로그램 카운터, Stack Pointer, Memory Page가 됩니다. 또 할당된 stack, heap 같이 포함됩니다. 프로세스가 갖는 중요한 특징이 있습니다. 각각의 프로세스는 메모리에서 독립적으로 공간을 받습니다. 하나의 프로세스가 다른 프로세스를 침범하지 않습니다. 대표적으로 크롬은 각각의 탭이 독립적인 프로세스를 갖습니다.

반면 쓰레드는 프로세스를 실행하는 단위입니다. 프로세스는 최소한 1개 이상의 쓰레드를 갖을 수 밖에 없습니다. 이것을 보고 메인 쓰레드라고 부릅니다. 프로세스가 멀티 쓰레드를 갖는 경우는 꽤 흔합니다. 각각의 쓰레드는 독립적인 스택, 레지스터, 프로그램 카운터를 갖습니다. 더 정확히 스택포인터, 레지스터, 프로그램 카운터는 쓰레드 속하다고 하는 것이 더욱더 정확합니다. 왜냐하면 포함관계 때문입니다. 하나의 프로세스에서 여러 쓰레드로 자원을 공유하는 것은 가능합니다. 메모리에서 힙을 통해서 자원을 공유할 수 있습니다. 하지만 주의할 점은 오류를 갖는 쓰레드가 다른 쓰레드 악영향을 줄 수 있고 프로세스 전체를 깰 수 있습니다.

운영체제는 CPU에 어떻게 프로세스를 실행하는가? 이것은 컨텍스트 스위칭으로 해결합니다. 컨텍스트를 스위칭할 때는 하나의 프로세스를 중단하고 다른 프로세스를 활성화합니다. 운영체제는 현재 실행 중인 프로세스를 잠시 저장합니다. 중단 된 프로세스를 재개하기 위해서 저장합니다.

컨텍스트 스위칭 비용은 비쌉니다. 레지스터에 저장하고 로딩하고 메모리 페이지를 바꾸고 다양한 커널 데이터 구조를 갱신하는 과정이 들어갑니다.

실행 중인 쓰레드를 전환하는 것도 컨텍스트 스위칭이 또 필요합니다. 일반적으로 쓰레드를 전환하는 것이 프로세스를 전환하는 것보다 빠르다고 알려져있습니다. 추적해야 하는 단계가 더 짧습니다. 하지만 더 큰 요인은 같은 메모리 공간을 공유하기 때문에 가상 메모리 페이지를 전환할 필요가 없습니다. 가상 메모리 페이지 전환은 컨텍스트 스위치 중 더 비싼 비용에 속합니다.

컨텍스트 스위칭은 너무 비쌉니다. 예를 들면, fibers, coroutines 같은 방법으로 개선해보려고 합니다. 더 로우레벨 컨텍스트 스위칭의 복잡성까지 추적합니다. 일반적으로 어플리케이션이 스스로 스케줄링을 처리합니다. 장시간 동작하기 위해 애플리케이션은 주기적으로 테스크를 쪼개야 하는 의무를 갖습니다.

# 포인터란 무엇인가?

# 테스크 스케줄링이란?

# 동시접근 문제는 무엇인가?

전산학에서 경쟁 상태란 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다. 동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다. 이를 방지하기 위해서는 프로세스 협력 기법이 필요하다.

여러가지 방법 중 하나는 뮤텍스입니다. 각각 독립적인 메모리 공간을 주고 독립적인 프로세스를 두도록 하고 자원 공유가 필할 때 언어 혹은 프레임워크에 맞게 알아서 설정하도록 합니다. 이 경우 자원이 분리되지만 언어나 프레임워크마다 자원 공유하는 전략에 맞게 활용합니다.

https://www.youtube.com/watch?v=4rLW7zg21gI

https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C

# 트리와 그래프 차이는 무엇인가

답변일자: 2023.03.24.

트리는 그래프의 포함관계입니다.

트리는 위계관계를 갖고 있습니다. 최상단은 root Node에 해당하고 1개만 존재할 수 있습니다. 최하단 Node는 leaf Node로 여러개가 존재할 수 있습니다. root를 제외하면 모든 Node는 부모를 갖습니다. 위에서 아래 혹은 아래에서 위로 움직이기 때문에 비순환 그래프에 속합니다. 트리의 예시는 DOM 트리, 족보, 조직도입니다.

그래프는 트리보다 넓은 의미를 갖습니다. Node와 간선을 표현한 자료구조입니다. 일반적인 의미의 그래프는 위계관계가 없습니다. 트리는 측면 피라미드로 위아래를 보는 도식이라면 그래프는 버드아이뷰로 평면을 보는 것과 비슷합니다. 그래프는 방향을 갖을지 말지 작성자의 자유입니다. 그래프의 순환도 작성자가 원하면 순환하도록 만들 수 있습니다. 주로 네트워크 모델에 많이 활용합니다.

# Base64 인코딩이란 무엇인가요?

Base64 인코딩이란 바이너리 데이터를 ASCII 코드로 변환하는 것이고 디코딩은 반대로 ASCII 코드를 바이너리 데이터로 변화는 과정입니다.

웹에서 바이너리 데이터를 전송해야 하는 경우, ASCII 문자만을 사용하는 제한된 환경에서 바이너리 데이터를 안전하게 전송활용할 수 있습니다. 예를 들어 image를 data-url로 변환하는 경우 또 이메일을 전송하는 경우입니다

인코딩과정은 다음과 같습니다. 바이너리 데이터를 6비트 단위로 쪼갭니다. 6비트인 이유는 64는 2의 6제곱이기 때문입니다. 쪼갠 6비트는 10진수로 변환합니다. 10진수로 0 ~ 63까지 Base64 Table을 기준으로 각각 해당하는 문자열로 변환합니다. 여기서 디코딩을 위해 문자열의 길이가 4배수가 될때까지 "="으로 채웁니다. 이렇게 되면 base64 인코딩에 성공한 것입니다.

## "="을 4의 배수로 채우는 이유는 무엇인가?

https://blue-boy.tistory.com/227

https://developer.mozilla.org/en-US/docs/Glossary/Base64

https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464

```js
let str = "Jake The Dog";
let strToASCII = parseInt(
  str
    .split("")
    .map((char) => char.charCodeAt())
    .join("")
); // 749710710132841041013268111103
let ASCIIToBinary = strToASCII.toString(2); // 1001011101100111001000101010000110010001010101110101100000000000000000000000000000000000000000000000

// 6자리마다 순회하기
// let binaryToBase64Idx = ASCIIToBinary.match(/.{1,6}/g).map((bit) => {
//   // bit.length === 6 ?

//   switch (bit.length) {
//     case 6:
//       return parseInt(bit, 2);
//     case 4:

//     default:
//       return null
//   }
// });
// const base64Table =
//   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// base64IdxToValue = binaryToBase64Idx.map((num) => base64Table[num]);

console.log(btoa(ASCIIToBinary));
```

## Base64를 사용하는 이유는 무엇인가?
