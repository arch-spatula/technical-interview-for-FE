# 쓰레드와 프로세스의 차이?

프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.

프로세스는 동립적이기 때문에 다른 프로세스에 문제를 일으킬 수 없습니다. 크롬은 각 탭을 독립적인 프로세스로 처리합니다.

스레드는 프로세스 속에서 실행하는 단위입니다. 최소 1개 이상의 쓰레드를 갖고 있고 이 쓰레드 이름은 메인 쓰레드라고 부릅니다. 쓰레드는 동일한 메모리 공간을 공유힉 때문에 스위칭이 없습니다.

컨텍스트 스위칭으로 여러 프로세스를 처리할 수 있습니다. 컨텍스트 스위칭은 계산비용이 비쌉니다.

[FANG Interview Question | Process vs Thread](https://www.youtube.com/watch?v=4rLW7zg21gI)

흔한 면접 질문입니다.

이 질문을 답하기 전에는 프로그램이 무엇인지 알아야 합니다. 사람들이 말하는 프로그램은 주로 실행파일입니다. 프로그램의 실행절차에 대한 코드는 디스크에 저장되어 있습니다. 프로그램을 실행하게 되면 메모리로 호출되고 프로세서가 프로세싱을 합니다. 이때 프로세스가 됩니다. 활성화된 프로세스는 프로그램을 실행하기 위한 리소스도 포괄해 지칭합니다. 이런 리소스들은 보통 운영체제로 제어됩니다. 예를 들면 프로세스 레지스터, 프로그램 카운터, Stack Pointer, Memory Page가 됩니다. 또 할당된 stack, heap 같이 포함됩니다. 프로세스가 갖는 중요한 특징이 있습니다. 각각의 프로세스는 메모리에서 독립적으로 공간을 받습니다. 하나의 프로세스가 다른 프로세스를 침범하지 않습니다. 대표적으로 크롬은 각각의 탭이 독립적인 프로세스를 갖습니다.

반면 쓰레드는 프로세스를 실행하는 단위입니다. 프로세스는 최소한 1개 이상의 쓰레드를 갖을 수 밖에 없습니다. 이것을 보고 메인 쓰레드라고 부릅니다. 프로세스가 멀티 쓰레드를 갖는 경우는 꽤 흔합니다. 각각의 쓰레드는 독립적인 스택, 레지스터, 프로그램 카운터를 갖습니다. 더 정확히 스택포인터, 레지스터, 프로그램 카운터는 쓰레드 속하다고 하는 것이 더욱더 정확합니다. 왜냐하면 포함관계 때문입니다. 하나의 프로세스에서 여러 쓰레드로 자원을 공유하는 것은 가능합니다. 메모리에서 힙을 통해서 자원을 공유할 수 있습니다. 하지만 주의할 점은 오류를 갖는 쓰레드가 다른 쓰레드 악영향을 줄 수 있고 프로세스 전체를 깰 수 있습니다.

운영체제는 CPU에 어떻게 프로세스를 실행하는가? 이것은 컨텍스트 스위칭으로 해결합니다. 컨텍스트를 스위칭할 때는 하나의 프로세스를 중단하고 다른 프로세스를 활성화합니다. 운영체제는 현재 실행 중인 프로세스를 잠시 저장합니다. 중단 된 프로세스를 재개하기 위해서 저장합니다.

컨텍스트 스위칭 비용은 비쌉니다. 레지스터에 저장하고 로딩하고 메모리 페이지를 바꾸고 다양한 커널 데이터 구조를 갱신하는 과정이 들어갑니다.

실행 중인 쓰레드를 전환하는 것도 컨텍스트 스위칭이 또 필요합니다. 일반적으로 쓰레드를 전환하는 것이 프로세스를 전환하는 것보다 빠르다고 알려져있습니다. 추적해야 하는 단계가 더 짧습니다. 하지만 더 큰 요인은 같은 메모리 공간을 공유하기 때문에 가상 메모리 페이지를 전환할 필요가 없습니다. 가상 메모리 페이지 전환은 컨텍스트 스위치 중 더 비싼 비용에 속합니다.

컨텍스트 스위칭은 너무 비쌉니다. 예를 들면, fibers, coroutines 같은 방법으로 개선해보려고 합니다. 더 로우레벨 컨텍스트 스위칭의 복잡성까지 추적합니다. 일반적으로 어플리케이션이 스스로 스케줄링을 처리합니다. 장시간 동작하기 위해 애플리케이션은 주기적으로 테스크를 쪼개야 하는 의무를 갖습니다.

## 프로세스가 디스크에서 프로그램이 호출 되어 주기억장치에서 처리되다면 호출은 무엇으로 되고 처리과정이 어떻게 되는가?

> 프로세스가 디스크에서 프로그램이 호출되어 주기억장치에서 처리되기 위해서는 먼저 프로그램을 실행하기 위한 명령어를 포함하는 프로세스를 생성해야 합니다. 이 프로세스는 운영체제가 관리하는 프로세스 테이블에 등록됩니다.
>
> 프로세스가 실행되기 위해선, 해당 프로세스를 호출하는 것이 필요합니다. 이 호출은 운영체제의 스케줄러에 의해 수행됩니다. 스케줄러는 실행 대기 중인 프로세스 중에서 CPU를 할당할 프로세스를 선택하고 해당 프로세스를 실행할 수 있도록 CPU를 할당합니다.
>
> 프로세스가 실행되면, 운영체제는 해당 프로세스를 위한 메모리 공간을 할당합니다. 이 메모리 공간에는 프로세스의 코드, 데이터, 스택 등이 포함됩니다. 프로그램의 명령어는 주기억장치의 메모리 공간에 로드되고, CPU는 이를 실행합니다.
>
> 프로세스가 실행되는 동안, 필요한 데이터는 주기억장치의 메모리 공간에 저장됩니다. CPU는 이 데이터를 주기억장치에서 로드하여 연산을 수행하고, 연산 결과를 다시 주기억장치에 저장합니다.
>
> 프로세스의 실행이 완료되면, 운영체제는 해당 프로세스를 종료시키고, 해당 프로세스의 자원(메모리 등)을 회수합니다. 이렇게 프로세스의 실행이 종료되면, 다른 프로세스가 CPU를 사용할 수 있게 됩니다.

### 프로세스 테이블이란 무엇인가?

### 서버에게 스케줄러란 무엇인가?

# 포인터란 무엇인가?

# 테스크 스케줄링이란?

# 동시접근 문제는 무엇인가?

전산학에서 경쟁 상태란 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다. 동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다. 이를 방지하기 위해서는 프로세스 협력 기법이 필요하다.

여러가지 방법 중 하나는 뮤텍스입니다. 각각 독립적인 메모리 공간을 주고 독립적인 프로세스를 두도록 하고 자원 공유가 필할 때 언어 혹은 프레임워크에 맞게 알아서 설정하도록 합니다. 이 경우 자원이 분리되지만 언어나 프레임워크마다 자원 공유하는 전략에 맞게 활용합니다.

https://www.youtube.com/watch?v=4rLW7zg21gI

https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C

# 트리와 그래프 차이는 무엇인가

답변일자: 2023.03.24.

트리는 그래프의 포함관계입니다.

트리는 위계관계를 갖고 있습니다. 최상단은 root Node에 해당하고 1개만 존재할 수 있습니다. 최하단 Node는 leaf Node로 여러개가 존재할 수 있습니다. root를 제외하면 모든 Node는 부모를 갖습니다. 위에서 아래 혹은 아래에서 위로 움직이기 때문에 비순환 그래프에 속합니다. 트리의 예시는 DOM 트리, 족보, 조직도입니다.

그래프는 트리보다 넓은 의미를 갖습니다. Node와 간선을 표현한 자료구조입니다. 일반적인 의미의 그래프는 위계관계가 없습니다. 트리는 측면 피라미드로 위아래를 보는 도식이라면 그래프는 버드아이뷰로 평면을 보는 것과 비슷합니다. 그래프는 방향을 갖을지 말지 작성자의 자유입니다. 그래프의 순환도 작성자가 원하면 순환하도록 만들 수 있습니다. 주로 네트워크 모델에 많이 활용합니다.

# Base64 인코딩이란 무엇인가요?

Base64 인코딩이란 바이너리 데이터를 ASCII 코드로 변환하는 것이고 디코딩은 반대로 ASCII 코드를 바이너리 데이터로 변화는 과정입니다.

웹에서 바이너리 데이터를 전송해야 하는 경우, ASCII 문자만을 사용하는 제한된 환경에서 바이너리 데이터를 안전하게 전송활용할 수 있습니다. 예를 들어 image를 data-url로 변환하는 경우 또 이메일을 전송하는 경우입니다

인코딩과정은 다음과 같습니다. 바이너리 데이터를 6비트 단위로 쪼갭니다. 6비트인 이유는 64는 2의 6제곱이기 때문입니다. 쪼갠 6비트는 10진수로 변환합니다. 10진수로 0 ~ 63까지 Base64 Table을 기준으로 각각 해당하는 문자열로 변환합니다. 여기서 디코딩을 위해 문자열의 길이가 4배수가 될때까지 "="으로 채웁니다. 이렇게 되면 base64 인코딩에 성공한 것입니다.

## "="을 4의 배수로 채우는 이유는 무엇인가?

https://blue-boy.tistory.com/227

https://developer.mozilla.org/en-US/docs/Glossary/Base64

https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464

```js
let str = "Jake The Dog";
let strToASCII = parseInt(
  str
    .split("")
    .map((char) => char.charCodeAt())
    .join("")
); // 749710710132841041013268111103
let ASCIIToBinary = strToASCII.toString(2); // 1001011101100111001000101010000110010001010101110101100000000000000000000000000000000000000000000000

// 6자리마다 순회하기
// let binaryToBase64Idx = ASCIIToBinary.match(/.{1,6}/g).map((bit) => {
//   // bit.length === 6 ?

//   switch (bit.length) {
//     case 6:
//       return parseInt(bit, 2);
//     case 4:

//     default:
//       return null
//   }
// });
// const base64Table =
//   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// base64IdxToValue = binaryToBase64Idx.map((num) => base64Table[num]);

console.log(btoa(ASCIIToBinary));
```

## Base64를 사용하는 이유는 무엇인가?

# Restful API에 대해 설명해주세요. GET,POST 외에 알고있는 메소드와 그 기준을 설명해주세요. RESTful API 가 아닌 것들은 어떤게 있나요?

Restful API는 클라이언트와 서버가 통신할 때 사용하는 http 메서드입니다. 메서드는 함수로 자원을 다루는 행위를 나타내기 때문에 사람이 이해하기 쉬운 API입니다. GET은 read, POST는 create, PUT 혹은 PATCH는 update, DELETE는 delete로 통신을 위한 API가 CRUD와 대응됩니다.

CRUD와 대응되는 메서드 이외에 지원하는 메서드를 확인하는 OPTIONS, 헬스 체크를 위한 HEAD, 프록시 기능을 요청할 CONNECT, 루프백 메시지 호출을 위한 TRACE가 있습니다.

Restful API이외에는 GraphQL도 존재합니다. Restful API는 직관적이지만 다소 경직되어 있습니다. 리소스를 호출할 때 불필요한 리소스도 같이 호출하게 됩니다. GraphQL은 유연하게 클라이언트가 필요한 리소스만 호출할 수 있습니다.

Restful API는 직관적이지만 한계가 있습니다. 초기 제품은 문제가 없지만 PMF가 검증되고 성숙하고 기능이 많은 제품은 다루어야 할 리소스와 방식들이 다양합니다.

## 그렇다면 GraphQL과 gRPC는 무엇인가?

# 캐시의 장단점과 어떤 부분에 활용하는지 설명해주세요. 프론트엔드에서 캐시를 사용할 수 있는 2~3가지 영역을 제시해주세요.

캐시의 장점은 접근 속도가 빠르다는 것입니다. 하지만 저장공간의 사이즈가 작습니다. CPU 내부에 캐시가 위치해있고 가장 최근 요청들을 저장해 놓고 또 요청이 있었을 때 캐시에 있는 데이터를 제공하는 방식으로 동작합니다. 하드웨에서 성능이 좋은 이유는 물리적으로 위치가 가깝습니다. 전기가 이동할 길이가 짧기 때문에 이동하는 시간이 덜 걸립니다. 캐시의 단점은 저장공간의 사이즈입니다. 저장할 수 있는 데이터의 크기가 작습니다. 또 가격도 비쌉니다.

프론트엔드에서 캐시를 사용할 수 있는 3가지 영역들이 있습니다.

첫째는 웹 캐시입니다. 다른 이름은 http 캐시입니다. 서버로 부터 요청 받은 자원들을 저장합니다. 웹 문서, 이미지, 웹 멀티미디어 등... 저장합니다.

둘째는 브라우저에 캐시처럼 활용할 수 있는 공간입니다. 로컬 스토리지, 세션 스토리지가 있습니다. 사용자 인허가와 관련된 데이터는 세션 스토리지를 활용합니다. 하지만 인허가와 무관할 경우 로컬 스토리지를 캐시처럼 활용합닏다. 웹 사이트에서 사용자가 보고 있던 탭, 입력 중이었는데 제출하기 전의 form 등을 저장할 때 많이 활용합니다.

마지막은 실제 메모리입니다. React-Query는 실제로 in-memory에 캐싱을 처리합니다. 하지만 직접 다룰 경우가 가장 없습니다. 물론 React-Query의 Optimistic Updates로 캐시를 갱신하는 것처럼 라이브러리를 통해서는 제어할 때가 많습니다.

[Where does the cache is stored in react-query? #3219](https://github.com/TanStack/query/discussions/3219)

## 소프트웨어 공학에서 토큰이란 무엇인가?

- 소프트웨어 공학에서 토큰은 어휘분석의 단위입니다.
  - 프로그래밍 언어의 경우 인터프리터 혹은 컴파일러를 통해 기계가 이해할 수 있게 변환해줘야 합니다. 이 번환을 위해 식별자, 연산, 예약어와 키워드 등 처리와 구분을 위한 최소단위를 말합니다.
  - 프로그래밍 언어가 아닌 경우에도 토큰 처리를 합니다. HTML의 경우 마크업 언어로 특정 태그의 열고 닫고 속성의 이름과 값을 분리하고 처리하는 것을 보고 토큰화 과정이라 합니다. 자연어 처리의 경우 특정 단어는 물론 관용적인 표현, 속담, 의성어, 의태어 등을 처리할 때도 사용하는 개념입니다.
  - 하지만 가장 쉬운 이해는 토큰은 문자를 어떤 기준을 갖고 덩어리로 구분하는 것으로 이해할 수 있습니다.

답변일자: 2023.04.26.

# CI/CD란 무엇인가?

코드를 자주 합치고 배포하자는 개발의 운영방식입니다.

먼저 CI는 계속적인 통합이라고 직역합니다. 여기서 통합하는 대상은 개발자의 코드입니다. 코드를 합칠 때는 여러 주의가 많이 필요합니다. 처음에는 작게 PR 리뷰를 통해 합치는 방식이 일반적이지만 코드베이스의 규모가 커지면서 타입체킹, 포멧체킹, 테스팅과 같은 과정 이후에 합칠 수 있도록 합니다. CI는 코드, 빌드, 테스트, 릴리스의 과정입니다.

CD는 배포, 운영, 모니터링, 계획의 과정입니다. 굉장히 복잡하거나 상태성을 갖는 시스템은 CD를 잘 실천하지 않습니다. 넷플릭스 백엔드 서비스처럼 복잡하거나 DB, 웹 소켓처럼 상태를 갖는 경우에 해당합니다. 하지만 무상태성을 갖는 시스템은 도입이 현실적입니다. CD는 신기능을 자주 출시하고 피처플래그를 감싸하서 버그가 발생하면 신기능을 바로 취소합니다. 또 전제 유저가 아닌 카나리 배포전략으로 특정 해비유저의 테스트 케이스를 모니터링하고 전체로 확대하는 전략을 적용합니다.

CI/CD를 잘 실천하면 좋은 개발환경과 품질높은 소프트웨어를 사용자에게 전달할 수 있습니다.

---

CI/CD In 5 Minutes | Is It Worth The Hassle: Crash Course System Design #2

https://www.youtube.com/watch?v=42UP1fxi2SY

CI/CD는 코드완성 후 커밋부터 배포까지 과정을 자동화합니다. 사람이 수동으로 제어해야 하는 부분을 자동화합니다.

소프트웨어팀이 더 높은 코드퀄리티로 제품을 전달한다고 합니다. 이론과 실제는 상황에 따라 다릅니다.

CI는 생각보다 쉽게 도입할 수 있습니다. 일찍 자주 공유하는 레포에 잘 병합하도록 합니다. CI는 보통 좋은 테스트에 의존을 많이 합니다. 테스트 커버리지가 높으면 처리시간이 길어집니다. 소스코드 서비스를 잘 활용해야 합니다. github actions를 많이 이용합니다. 빌드 테스트 배포를 자주 합니다. 보통 테스트는 언어에 좌우되기도 합니다. 빌드는 상태계에 따라 다르게 적용해야 합니다. 자바스크립트의 경우 웹팩이 가장 널리 사용합니다.

CD는 계속적인 배포입니다. 존재는하지만 생각보다 어렵습니다. 많은 경우 CI만 도입하는 경우가 많습니다. 대부분 팀은 아주 기본적인 시스템에서만 CD를 도입합니다. 웹서버 티어 혹은 API처럼 무상태성을 갖는 경우에 적용합니다. 보통 이런 무상태성을 갖는 시스템에 도입하는 이유는 롤백이 쉽고 리스크가 낮습니다. 또 신기능으 피처플래그로 감싸는 경우가 일반적입니다. 배포와 활성화를 분리합니다. 이렇게 하는 이유는 완전한 롤백 없이 특정 기능만 해제하기 위해서 적용합니다. 규모가 큰 시스템에는 카나리 배포를 활용하는 경우가 흔합니다. 보통 파워유저에게 먼저 배포하고 여기서 버그를 찾고 전체로 배포합니다. 이렇게 하면 피해범위는 축소하고 실제와 비슷한 환경에서 실험해볼 수 있게 됩니다. 상태를 갖는 시스템(DB, 웹 소캣)에는 대부분 CD를 실천하지 않습니다. 이런 경우 전념하는 플랫폼 팀이 따로 필요합니다. CD로 github action, buildkite, jenkins를 자주 사용합니다. k8r는 argo CD를 많이 활용합니다.

모두에게 적용할 수 있는 것은 아니고 시스템의 규모와 복잡도에 따라 다르게 적용해야 합니다.
