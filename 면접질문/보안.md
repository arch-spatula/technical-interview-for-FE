# 해킹은 무엇인가?

> 해킹(Hacking)은 컴퓨터 시스템 및 네트워크에 대한 불법적인 접근, 조작, 파괴 등을 포함하는 컴퓨터 보안 분야에서 사용되는 용어입니다. 일반적으로 해킹은 다음과 같은 목적으로 수행됩니다.
>
> 시스템/네트워크 침입: 해커들은 네트워크 및 시스템에 접근하여 불법적인 액세스 권한을 얻습니다. 그들은 시스템 관리자의 권한으로 서버, 데이터베이스, 애플리케이션, 파일 등에 액세스할 수 있습니다.
>
> 데이터 유출: 해커들은 타인의 개인 정보, 비즈니스 비밀, 국가 비밀 등을 유출할 수 있습니다. 이러한 정보는 개인, 기업 또는 국가에 막대한 피해를 입힐 수 있습니다.
>
> 서비스 거부: 해커들은 서버를 공격하여, 해당 서버에서 호스팅되는 웹사이트나 애플리케이션에 대한 서비스를 거부시키는 DoS/DDoS 공격 등을 수행합니다.
>
> 악성 코드 삽입: 해커들은 악성 코드를 삽입하여 시스템 또는 네트워크를 파괴하거나 다른 공격자에게 접근을 제공할 수 있습니다.
>
> 이러한 공격은 매우 심각한 결과를 가져올 수 있으며, 공격에 대비하기 위해서는 보안 조치를 강화하고, 취약점을 최소화하는 등의 방법을 통해 대응해야 합니다.
>
> - chatGPT의 답변

# 크래킹은 무엇인가?

> 크래킹(Cracking)은 소프트웨어, 게임, 운영 체제 등에 대한 보안 메커니즘을 우회하거나 깨뜨려서, 불법적으로 해당 소프트웨어를 사용하거나, 다른 사용자에게 판매하거나, 그 외의 목적으로 이용하는 것을 말합니다.
>
> 일반적으로, 크래킹은 소프트웨어의 저작권을 침해하며, 법적인 문제가 발생할 수 있습니다. 또한, 크래킹된 소프트웨어는 보안에 취약하며, 사용자의 개인 정보나 기밀 정보를 탈취하는 악성 코드가 포함될 수 있습니다.
>
> 크래킹은 소프트웨어 개발사들이 소프트웨어에 대한 보안 조치를 강화하는 주요 원인 중 하나입니다. 이러한 보안 조치로는, 소프트웨어의 라이센스 인증, 복호화 기술, DRM(Digital Rights Management) 등이 있습니다.
>
> - chatGPT의 답변

# CORS란 무엇이고 어떻게 허용할 수 있나요?

CORS 같은 기초적인 질문을 답할 수 없었습니다. 왜 정책을 허용하면 보안에 취약해지는지 몰랐습니다.

CORS는 Cross-Origin Resource Sharing의 약어입니다. Cross-Origin에서 먼저 Origin은 URL에서 프로토콜, 도메인, 포트번호를 보고 Origin 이라고 부릅니다. 이 Origin은 요청의 원천을 의미합니다. 클라이언트 컴퓨터는 통신할 때 header에 Origin 정보를 담고 요청을 보냅니다. 그리고 Resource는 서버가 갖고 있는 정보를 의미합니다. Sharing은 공유인데 서버가 갖고 있는 정보를 공유받을 수 있는 의미입니다. 서버는 요청을 받으면 Origin과 같으면 요청한 리소스를 응답하고 다르면 에러로 응답합니다. 즉 교차 원천에서도 리소스를 공유하고 접근할 수 있게 허용하는 정책입니다. 이 정책은 백엔드 엔지니어가 결정하는 보안정책입니다.

허용을 하기 위해서는 먼저 서버가 받을 응답 모드에 cors가 허용되어야 합니다. 그리고 클라이언트가 요청 header의 mode에 cors라고 키와 값을 설정하면 CORS 정책이 허용됩니다.

```js
const express = require("express");
const cors = require("cors");

const app = express();

const corsOptions = {
  origin: true,
  credentials: true,
};
app.use(cors(corsOptions)); // 모든 cross origin 요청 허용
```

보통 개발환경에서 실제 서버랑 통신을 테스트할 때 허용합니다.

```txt
CORS (Cross Origin Resource Sharing) 란 가져오는 리소스들이 안전한지 검사하는 브라우저의 방화벽이라고 생각합니다. Cross-Origin Resource Sharing" 문장을 직역하면 "교차 출처 리소스 공유 정책"이라고 해석할 수 있는데, 여기서 교차 출처라고 하는 것은 (엇갈린) 다른 출처를 의미하는 것으로 보면 됩니다. 여기서 Origin이란 protocol 과 Host 그리고 Port 까지 모두 합친 URL을 의미합니다. Access-Control-Allow-Origin 응답 헤더 세팅 서버측 응답에서 접근 권한을 주는 헤더를 추가하여 해결할 수 있습니다. 또한 cors 모듈 사용하여 아무 옵션없이 설정하면 모든 cross-origin 요청에 대해 응답이므로, 특정 도메인이나 특정 요청에만 응답하게 옵션을 설정할 수 있다. 특정 도메인 접근 허용 및 특정 요청 접근 허용등이 있다.
```

https://evan-moon.github.io/2020/05/21/about-cors/

## CORS를 허용하면 왜 보안에 취약해지는가?

> CORS (Cross-Origin Resource Sharing)는 웹 어플리케이션에서 다른 도메인으로부터 리소스를 요청할 수 있도록 허용하는 메커니즘입니다. 이는 웹 개발자들이 다른 도메인에서 호스팅되는 리소스 (예: 이미지, 스크립트, 폰트 등)를 가져와서 웹 어플리케이션에서 사용할 수 있게 해줍니다.
>
> CORS를 허용하는 것은 보안에 취약해지지 않습니다. 실제로, CORS는 보안을 높이는 방법 중 하나입니다. 하지만 올바르게 구성되지 않은 경우 보안 위험이 발생할 수 있습니다.
>
> 만약 서버에서 Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'를 허용한다면, 모든 도메인이 서버의 리소스에 접근할 수 있습니다. 이 경우, 서버는 의도하지 않은 도메인으로부터의 요청도 허용하게 됩니다. 이는 CSRF (Cross-Site Request Forgery) 공격 등의 보안 문제를 일으킬 수 있습니다.
>
> 따라서, 서버에서는 가능한 최소한의 도메인만 허용하도록 Access-Control-Allow-Origin 헤더를 설정해야 하며, 이를 통해 보안 취약점을 최소화해야 합니다. 또한, 요청을 검증하고 권한을 확인하는 등의 보안 메커니즘을 구현하여 안전한 웹 어플리케이션을 만들어야 합니다.
>
> - chatGPT의 답변

다음은 저의 답변입니다.

단순히 CORS 설정만 하는 것으로 취약해지는 것은 아닙니다. 어떤 서비스는 다른 외부 API도 활용하는 경우가 흔합니다. 예를 들어, 기상청, 카카오 지도 같은 API는 다른 서비스들이 요청을 보낼 수 있는 API입니다. 취약해지려면 Access-Control-Allow-Origin에 '\*'으로 모두 허용하면 문제가 됩니다. 이 경우 CSRF에 취약해집니다. 예를 들어 `https://abc.xyz`가 존재합니다. 그리고 해커는 `https://abcd.zyx`라는 가짜 사이트를 만듭니다. 가짜 사이트를 구분할 수 없던 사용자는 가짜 사이트에서 로그인 인증을 하고 이 인증 정보를 활용합니다. 즉 해커는 사용자 정보를 활용해 본인의 요청을 위조할 수 있게 됩니다.

단순히 CORS 설정만이 아니라 모든 요청을 허용하면 문제가 됩니다. 그래서 요청의 차별을 둘 수 있게 신뢰할 수 있는 출처만 허용되게 만듭니다. 또 로그인과 무관하게 읽기 전용 API key를 통해 허용하는 방법도 있습니다.

## CSRF (Cross-Site Request Forgery) 공격은 무엇인가?

> CSRF (Cross-Site Request Forgery) 공격은, 인터넷 사용자가 의도하지 않은 요청을 실행하게 만드는 공격 기술입니다. 이 공격은 사용자가 로그인한 웹사이트에 대한 인증 정보를 이용하여, 악성 사용자가 제작한 요청을 실행하는 것입니다.
>
> 예를 들어, 사용자가 은행 웹사이트에 로그인한 상태에서, 공격자가 제작한 악성 웹사이트를 방문하게 되면, 악성 웹사이트는 은행 웹사이트에 대한 요청을 실행시킬 수 있습니다. 이 요청은 사용자가 은행 웹사이트를 이용할 때 사용한 인증 정보를 이용하며, 은행 웹사이트에서는 해당 요청이 유효한 것으로 인식하여 실행하게 됩니다. 이를 통해 공격자는 사용자의 은행 계좌를 조작하거나, 비밀번호를 변경하는 등의 행동을 할 수 있습니다.
>
> 이를 방지하기 위해서는, 서버 측에서 적절한 보안 메커니즘을 구현하고, 사용자 측에서는 인증 정보를 보호하는 등의 조치를 취해야 합니다. 예를 들어, CSRF 토큰을 사용하여 요청이 유효한 것인지 검증하거나, 사용자가 인증 정보를 입력하는 폼에 대해 캡차를 적용하는 등의 방법이 있습니다. 이를 통해 CSRF 공격을 예방할 수 있습니다.
>
> - chatGPT

다양한 Origin 허용을 활용해서 사용자 정보를 얻고 위조하는 것으로 리소스를 접근하는 공격입니다.

## XSS(Cross-Site Scripting) 공격은 무엇인가?

> XSS (Cross-Site Scripting) 공격은 웹사이트의 취약점을 이용하여, 악성 스크립트를 삽입하여 공격자가 웹사이트에 접속한 사용자들의 브라우저에서 실행되게 만드는 공격 기술입니다.
>
> 공격자는 웹사이트에 삽입된 스크립트를 이용하여, 사용자들의 정보를 탈취하거나, 사용자들을 다른 악성 사이트로 이동시켜 악성 코드를 실행시키는 등의 행동을 할 수 있습니다. 이를 통해 사용자들의 브라우저를 제어하거나, 사용자들의 개인정보를 탈취하는 등의 피해를 입힐 수 있습니다.
>
> XSS 공격을 방지하기 위해서는, 웹사이트의 취약점을 최소화하고, 사용자들이 입력하는 데이터를 검증하여 악성 스크립트가 삽입되지 않도록 해야 합니다. 또한, 쿠키와 같은 사용자 정보를 다루는 경우에는 안전한 방식으로 다루어야 하며, 브라우저에서 스크립트가 실행되는 환경을 최소화하도록 하는 등의 방법을 적용해야 합니다. 웹개발자는 특히 입력 데이터의 검증, 필터링, 이스케이핑 등의 방법을 적극적으로 활용해야 합니다.
>
> - chatGPT

# Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'를 허용하면 CSRF (Cross-Site Request Forgery) 공격에 취약해지는 이유는 무엇인가?

```txt
Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'를 허용하면, 해당 도메인에서 실행되는 스크립트를 제외한 다른 도메인에서도 해당 도메인의 자원에 접근할 수 있게 됩니다. 이 경우, CSRF 공격자는 자신의 웹사이트에서 악성 스크립트를 실행시켜, 희생자가 인증된 상태에서 다른 도메인에 있는 악성 사이트에 접속하면, 해당 도메인의 자원에 접근할 수 있는 요청을 보낼 수 있게 됩니다.

즉, CSRF 공격자는 악성 스크립트를 실행시킨 희생자의 브라우저를 이용하여, 해당 도메인에서 실행되는 요청을 보내는 것이 아니라, 다른 도메인에서도 해당 도메인의 자원에 접근할 수 있는 요청을 보낼 수 있게 됩니다. 이렇게 되면, 희생자의 인증 정보를 이용하여 다양한 피해를 입힐 수 있게 됩니다.

따라서, Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'를 허용하는 것은 보안상 매우 위험한 방법입니다. 대신, 필요한 경우, 신뢰할 수 있는 도메인에 대해서만 허용하도록 하는 것이 좋습니다. 이를 위해서는 Access-Control-Allow-Origin 헤더를 명시적으로 설정하고, 도메인을 지정하여 사용하는 것이 좋습니다. 또한, CSRF 방어 ... (네트워크 에러)
```

```txt
Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'를 허용하는 것은 CORS (Cross-Origin Resource Sharing) 정책에서 보안 상의 위험을 야기할 수 있습니다.

CORS는 보안을 위해 브라우저에서 실행되며, 동일 출처 정책(same-origin policy)을 적용하여 다른 출처(origin)에서 리소스에 접근하는 것을 제한합니다. 그러나, CORS를 통해 다른 출처에서 리소스에 접근을 허용하는 경우, 이러한 출처에서 악의적인 요청을 보낼 수 있어 CSRF 공격에 취약해집니다.

만약, Access-Control-Allow-Origin 헤더를 모든 도메인에 대해 '\*'로 허용하면, 모든 출처에서 리소스에 접근할 수 있어, CSRF 공격을 수행하는 악성 스크립트가 다른 출처에서 리소스에 접근할 수 있게 됩니다. 따라서, 이러한 상황에서는 리소스에 접근을 허용하는 출처를 명시하여 보안성을 유지하는 것이 중요합니다.

따라서, CORS 설정에서는 Access-Control-Allow-Origin 헤더에 '\*' 대신, 신뢰할 수 있는 출처만을 허용하도록 설정하는 것이 좋습니다. 이를 통해 CSRF 공격을 방지하고, 보안을 유지할 수 있습니다.
```

네트워크 에러로 2번의 답변을 받았습니다.

# 세션과 쿠키를 비교하여 설명해주실 수 있을까요?

답변일자: 2023.03.23.

[Session vs Token Authentication in 100 Seconds](https://www.youtube.com/watch?v=UBUNrFtufWo)

세션은 쿠키의 포함관계입니다.

쿠키는 브라우저에 저장되는 텍스트이고 key-value 형태로 저장됩니다. 서버랑 통신하면서 set-cookie를 키로 header에 포함하고 주고 받습니다. 서버에 http 요청을 보낼때 쿠키는 자동으로 같이 보내집니다. 물론 단일 origin, CORS에서 허용된 Origin만 받습니다.

세션이란 클라이언트와 서버 사이 연결이 활성화된 상태를 의미합니다. 또는 인증이 유지되는 상태라고 합니다. 사용자가 로그인에 성공하면 서버는 세션을 생성하고 key-value 형식으로 저장합니다. 그리고 여기서 key를 응답합니다. 이 응답받은 값은 쿠키에 저장됩니다. 세션은 서버가 일정 시간동안 저장하고 있는 것이기 때문에 만료가 될 수 있습니다. 최근 요청 시간을 기준으로 많이 활용합니다. 또 서버는 요청 세션id를 활용해서 인가가 필요한 요청을 승인 또는 거절합니다.
