https://dev.to/said7388/top-10-react-js-interview-questions-48dc

https://dev.to/said7388/top-20-reactjs-interview-questions-3a0m

# 리액트의 휴리스틱 알고리즘이란 무엇인가?

먼저 휴리스틱스는 인간이 간단한 판단을 하기위한 어림잡기라는 의미입니다. 이 어림잡기를 리액트 알고리즘에 적용하면 랜더링을 효율적으로 처리하기 위해 내부적으로 갖고 있는 어림잡기들이 있습니다. 예를 들어 배칭같은 현상은 최종 state값을 한번에 DOM에 적용하는 동작방식이 해당합니다.

[라이브러리? 프레임워크? 차이점 아직도 모름? 5분 순삭.](https://www.youtube.com/watch?v=t9ccIykXTCM)

모두 다른 프로그래머가 작성한 코드입니다. 일반적으로 휴리스틱스는 사전적으로 한번에 너무 많은 정보를 고려하기 어려워 그 상황에서 최선의 간편추론법이라고 정의합니다. 저는 더 쉬운 표현인 어림잡기라는 의미로 접근합니다. 이런 어림잡기를 리액트의 DOM 생성 알고리즘에 적용한 것입니다. 어림잡는 것은 리액트가 가장 효율적으로 랜더링할 것을 어림잡을 것입니다. 이 어림잡기의 주체는 페이스북의 리액트 개발팀이고 어림잡을 대상은 리액트의 소비자인 대부분의 프론트엔드 엔지니어가 제어하는 컴포넌트입니다. 리액트가 탄생하기 직전 시대에는 DOM을 직접 조작하는 경우가 많았습니다. 하지만 UI에 변화가 없는데 다시 동일한 계산을 많이 하면서 낭비가 많았었습니다. 리액트 이후에는 DOM의 제어를 엔지니어가 프레임워크에게 위임하고 엔지니어는 가상 DOM으로 간접적으로 제어하고 다시 계산할 필요없는 함수를 실행하지 않으면서 효율을 높였습니다. 리액트 팀은 이 DOM을 조작해서 만드는 UI를 가장 효율적으로 처리하기 위해 일렬의 어림잡기들이 있습니다. 첫째로 부모컴포넌트가 리랜더링되면 자식 컴포넌트가 리랜더링 되는 것이 하나입니다. 다른 하나는 `useState`가 갖고 있는 두번째 배열 원소 setter함수의 실행이 리랜더링을 트리거합니다. 어디까지나 이렇게 리랜더링해야 가장 효율적이라고 가정하고 만든 것이기 때문에 가정에 해당하지 않는 부분은 소비자가 되는 엔지니어가 알아서 처리해야 합니다.

# 배칭

쉬운 질문입니다.

```tsx
import { useState } from "react";
const useTest1 = () => {
  const [value, setValue] = useState(0);
  setValue(value + 1);
  setValue(value + 1);
  setValue(value + 1);

  return value;
};

const useTest2 = () => {
  const [value, setValue] = useState(0);
  setValue((prevNum) => prevNum + 1);
  setValue((prevNum) => prevNum + 1);
  setValue((prevNum) => prevNum + 1);

  return value;
};
```

2개의 커스텀 hook이 있습니다. 각각 어떤 값을 반환하는지 설명하고 왜 그 값을 반환하는지 설명해주시기 바랍니다.

useTest1은 1을 반환합니다. useTest2는 3입니다. 이렇게 동작하는 이유는 배칭과 콜백함수의 참조대상이 원인이 됩니다. 배칭은 리액트가 VDOM으로 로직을 처리하고 몰아서 한번에 실제 DOM으로 랜더링할 때 일부처리를 보류합니다. 그 중에 state를 콜백함수가 아닌 값을 넣을 때 해당합니다. state에 대입할 수있는 값은 원시형인 숫자, 문자열, 불리안 그리고 원시형에서 엄밀하게 예외에 해당하는 null은 괜찮지만 참조형 자료는 콜백함수를 대합하고 기존 state값을 참조하고 있는 콜백함수의 인자를 복사하고 조작하는 방식으로 업데이트합니다. 하지만 콜백함수로 업데이트하는 자료는 배칭의 대상으로 몰아서 처리하지않고 즉시 처리합니다. useTest1은 참조하고 있는 기존 state값도 없기 때문에 `setValue(0+1)`를 3번 한 것입니다. 배칭이 처리가되었을 때 setter함수가 값을 고정시키는데 기존 값을 그대로 두고 있기 때문에 1번만 적용된 것입니다.

# cache time stale time에 대해서 설명해주시기 바랍니다.

# Toast ui의 Viewer가 리랜더링하기 위해서 어떻게 되어야 하나요?

TOAST ui는 비제어 input으로 리랜더링을 트리거하기 위해서는 매번 새로운 인스턴스를 만들어줘야 합니다.

리액트 이전 시대의 라이브러리로 리액트에 적응하는데 한계가 많은 라이브러리입니다. 활용한 자료를 탐색하기는 쉽습니다.

https://github.com/nhn/tui.editor/blob/master/docs/en/viewer.md

## 객체지향 프로그래밍에서 팩토리 패턴에 대해서 설명해주시기 바랍니다.

# CSS in CSS와 CSS in JS의 중요한 차이는 무엇인가요?

- 성능과 개발경험의 차이입니다.
  - CSS in CSS가 개발경험과 프로그래머로서 스타일 제어난이도가 더 높습니다. 하지만 성능에 더 유리합니다.
  - CSS in JS는 개발경험이 좋고 프로그래머로서 스타일 제어가 수월합니다.
- 물론 스타일링을 제어하기 위해 다양한 접근들이 있습니다. TailwindCSS의 경우 유틸클래스를 활용해서 CSS in CSS 성능이 좋으면 코로케이션의 장점을 갖을 수 있습니다. 물론 인라인 스타일이라는 단점도 존재합니다. 하지만 제품의 이터레이션을 자주 돌고 제품 스타일이 가변적이라면 유지보수하기 편한 라이브러리 보단 Tailwind처럼 빠르게 만다는 스타일링 유리할 수 있습니다.
  - Tailwind가 CSS in CSS가 되는 이유는 유틸클래스를 브라우저로 전달할 때 컴파일을 해서 전달하기 때문에 결국은 CSS in CSS가 됩니다.

# 리액트 포탈은 무엇이고 왜 사용해야 하는가?

답변일자: 2023.04.04.

- 다른 hootRootNode를 만들어 독립적으로 동작해야 하는 리액트 컴포넌트를 만들 때 사용합니다.

# 고차컴포넌트란 무엇인가?

# 클래스 컴포넌트와 함수 컴포넌트는 내부적으로 어떻게 다른가?

문법적인차이는 생략하겠습니다.

# 브라우저 렌더링 과정에 대해 아는 만큼 설명해주실 수 있을까요? 예를 들어 화면에서 DOM이 어떻게 결정되고, CSS는 어떻게 입혀지는지 등을 언급해주시면 좋습니다.

https://tecoble.techcourse.co.kr/post/2021-10-24-browser-rendering/

https://d2.naver.com/helloworld/59361

5단계로 렌더링을 처리합니다. 파싱, 스타일, 레이아웃, 페인트, 컴포짓입니다. 1단계는 HTML 파일과 CSS 파일 파싱입니다. 파싱으로 DOM Tree, CSSOM Tree를 만드는 것으로 시작합니다. 2단계는 스타일입니다. HTML과 CSS를 결합하고 Rendering Tree를 만드는 과정입니다. 3단계는 레이아웃입니다. Rendering Tree에서 각 노드의 위치와 크기를 계산하는 과정입니다. 4단계는 페인트입니다. 렌더 트리의 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만드는 과정입니다. 5단계는 컴포짓입니다. 만들어진 레이어들을 합성해 화면상 나타나게 됩니다.

visibility같은 속성이 적용됩니다.

여기 hight, width 같은 element의 크기 값들 픽셀로 변환하고 적용합니다.

# Lazy loading과 Code splitting에 대해 아는 만큼 설명해주실 수 있을까요?

Lazy loading과 Code splitting 모두 클라이언트 리소스를 덜 전달하는 것으로 로딩시간을 개선해 사용자 경험을 긍정적으로 만들기 위한 방법들입니다.

Lazy loading은 로딩을 지연하거나 특정 자원이 진짜 필요해지기 전까지 로딩을 막아서 성능을 개선하거나 시스템 자원을 절약하는 방법입니다. 예를 들어 이미지 태그에 loading 속성을 "lazy"로 설정하는 것으로 이미지 로딩을 지연시킬 수 있습니다. 그외 텍스트는 Lazy loading 설정을 하지 않아 화면상에 바로 보이도록 합니다.

Code splitting은 파일 모듈을 적절한 번들 및 컴포넌트 단위로 클라이언트의 요청에 따라 혹은 병렬로 로딩하는 방법입니다. 프로젝트를 진행하면 전체 파일의 규모가 엄청나게 커질 수 있습니다. 하지만 이 큰 파일을 통체로 클라이언트에게 전달하기 보단 작은 여러 파일로 분할하고 전달합니다. 필요한 스크립트가 사용자의 필요를 기준으로 lazy하게 로딩할 수 있습니다.

Lazy loading이 전략이라면 Code splitting은 전술에 해당합니다.

---

Lazy loading is the practice of delaying load or initialization of resources or objects until they're actually needed to improve performance and save system resources.

```html
<!-- These resources will be loaded immediately -->
<img src="header_image.jpg" />
<img src="header_image2.jpg" loading="eager" />

<!-- While these resources will be lazy loaded -->
<img src="article_image.jpg" alt="..." loading="lazy" />
<iframe src="video-player.html" title="..." loading="lazy"></iframe>
```

https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting

https://helloinyong.tistory.com/297

https://web.dev/browser-level-image-lazy-loading/

https://www.imperva.com/learn/performance/lazy-loading/

https://en.wikipedia.org/wiki/Lazy_loading

## Lazy loading을 어떻게 구현할 수 있는가?

## Code splitting은 어떻게 구현할 수 있는가?

# Next.js의 fallback에 대해서 설명해주시기 바랍니다.

fallback은 빌드할 때 리소스를 절약하는 전략으로 활용할 수 있습니다.

SSG는 일반적으로 빌드타임에 실행됩니다. 보통 커머스의 경우 제품의 종류가 많기 때문에 상세페이지가 10_000개를 금방 넘습니다. 10_000개의 페이지를 물론 클라우드를 빌려서 랜더링할 수 있습니다. 하지만 빌드 타임에 랜더링이 되고 랜더링을 위해 다른 서버에 10_000넘는 요청을 보내게 됩니다. 상당히 낭비가 큽니다.

이럴 때는 fallback을 true로 설정하고 SSG에서 사용자가 자주 방문하는 품목 페이지 몇개만 프리랜더링을 하는 전략으로 활용할 수 있습니다. 그리고 사용자가 방문 빈도가 낮은 페이지를 요청하면 fallback page를 먼저 보여주고 서버는 getStaticProps를 실행해서 JSON을 실행한 다음에 화면상 존재하는 props를 바꿔치기합니다. 이렇게 되면 사용자는 레이아웃 쉬프트를 경험하지 않은 것이 됩니다.

https://nextjs.org/docs/api-reference/data-fetching/get-static-paths

# 프레임워크와 라이브러리의 차이란 무엇인가?

프레임워크와 라이브러리의 차이는 다양한 접근이 가능합니다. 제어의 주체로 접근할 수 있고 반제품과 부품으로 접근할 수 있습니다.

먼저 라이브러리입니다. 라이브러리의 제어의 주체는 프로그래머입니다. 프로그래머가 라이브러리를 호출하고 소비합니다. 라이브러리는 특정 종류의 문제만 해결하고 그 외에는 코드를 어떻게 작성해야 하는 의견이 없습니다. 리액트는 공식 문서에서 소개하기로 UI 라이브러리입니다. 그리고 그 이름에 맞게 UI를 만드는 것 이외에 특별한 의견이 없습니다. 상태를 어떻게 관리할지, 스타일링을 어떻게 할지, 통신을 어떻게 처리할지, 라우팅 등... 프론트엔드 엔지니어로서 UI를 생성하는 방식 이외에 모두 결정을 내려야 합니다. 이런 측면에서 부품에 해당합니다. 제품을 완성하기 위해 많은 부품들을 검토가 필요합니다.

프레임워크의 제어의 주체는 프로그래머의 코드입니다. 즉 제어관계가 역전된 것입니다. 프레임워크는 코드를 어떻게 작성해야 하는지 대부분의 경우 의견을 갖고 있습니다. 문제를 어떻게 해결해야 하는지 프레임워크가 대신 정해준 것입니다. Next.js는 리액트 프레임워크에 해당합니다. 라우팅, 통신, 스타일링, 최적화 전략 등... 다양한 부분에서 프레임워크가 대신 정해줬습니다. 즉 몇가지 소수로 결정이 안 된 부분만 결정하고 프로그래머의 코드로 반제품을 완제품으로 만들면 됩니다.

---

답변에 리팩토링이 필요합니다.

[라이브러리? 프레임워크? 차이점 아직도 모름? 5분 순삭.](https://www.youtube.com/watch?v=t9ccIykXTCM)

모두 다른 프로그래머가 작성한 코드입니다.

라이브러리는 부품이기 때문에 교체하면 문제가 생기면 안 됩니다. 예전에 TOAST UI 텍스트 에디터를 사용했지만 번들 사이즈 때문에 wui textarea로 교체를 했었습니다. 즉 라이브러리를 교체한 것입니다. 하지만 프레임워크를 교체하면 곤란합니다. Next.js와 Remix.js로 교체하면 천문학적인 문제가 발생할 수 있습니다.

## 또 여기서 추가 문제가 있습니다. 그렇다면 API는 무엇인가?

API를 직역하면 응용 프로그램 인터페이스입니다. 여기서 응용은 다른 사람이 만들어 놓은 것을 소비하게 된다는 의미로 받아 들일 수 있습니다. 그리고 프로그래밍 인터페이스에서 인터페이스는 제어장치라고 생각할 수 있습니다. 프로그래머가 클래스 혹은 함수에 좋은 인터페이스를 만들었다고 하면 소비자 입장에서 제어가 직관적이라는 의미입니다. 즉 프로그래밍 인터페이스는 프로그램으로 제어하기 좋다는 의미입니다. 물론 이것은 상당히 포괄적인 의미에서 API입니다.

하지만 웹, 어플리케이션 등 분야에서는 요청과 응답의 중간다리로 볼 수 있습니다. 통신을 위해 클라이언트가 어떻게 리소스를 요청할지 또 그 요청에 서버가 어떻게 응답할지 정한 약속으로도 볼 수 있습니다.

---

[[10분 테코톡] 📢 욘의 프레임워크 vs 라이브러리 vs API](https://www.youtube.com/watch?v=_j4u4ftWwhQ)

# 클래스 컴포넌트와 함수 컴포넌트가 리랜더링할 때 내부적으로 어떻게 다른가?

`shouldComponentUpdate`라는 라이프사이클 hook의 실행 여부가 내부적으로 다릅니다.

클래스 컴포넌트의 경우 props, state의 값을 렌더 이전과 이후를 비교하고 다를 때 true를 반환해서 리렌더링합니다. 이전과 이후 비교할 때 원시형은 이미 불변성을 보장받기 때문에 문제가 없지만 참조형의 경우 참조동일성 문제로 복제를 통해 참조동일성을 깨야 합니다. 참조동일성이 깨져야 다른 값으로 보고 값의 갱신으로 인지하고 true를 반환해서 리렌더링합니다.

함수 컴포넌트의 경우 라이프사이클 메서드가 없습니다. 또 `shouldComponentUpdate`와 같은 메서드를 제어하는 것은 불가능하지만 내부적으로 설계한 의도는 비슷합니다. 함수 컴포넌트는 props는 비슷하게 내부적으로 동작합니다. 하지만 state는 useState hook을 활용해서 shouldComponentUpdate를 내부적으로 동작하도록 해야 합니다.

## 리액트 라이브러리의 아키텍쳐를 통해서 설명해주시기 바랍니다.

# useRef가 필요한 상황을 예시를 들어 설명해주세요

- 가장 많이 useRef를 사용했던 경우는 JSX에서 DOM을 선택하는 경우였습니다. hook의 본래 의도는 아닙니다. 하지만 많이 사용하면서 정착하게 되었습니다.
- 리액트의 라이프사이클의 영향을 받지 않고 값을 저장해야 할 때 활용합니다. 즉 값이 Props, State가 아닌 값으로 보관해서 갱신되어도 리렌더링을 시키지 않기 위해 활용합니다.
- DOM 노드의 위치나 크기를 측정하기 위해 활용합니다.
- 참고로 어떤 활용이든 Ref를 접미어로 붙이는 것이 컨벤션은 동일합니다.

## DOM Ref

리액트를 처음배우고 DOM을 조작하고 제어할 때 활용하는 방식입니다.

```tsx
import { useRef, useEffect } from "react";

export const DomRef = () => {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
};
```

이렇게 DOM 선택을 할 수 있습니다.

참고로 custom hook으로 활용하기 위해 특정 DOM만 선택가능하도록 제네릭도 활용할 수 있습니다.

```tsx
import { useRef, useEffect } from "react";

export const DomRef = () => {
  const inputRef = useRef<HTMLInputElement>(null!);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
};
```

이렇게 하면 오직 input만 지정할 수 있게 만들 수 있습니다.

원래 의도한 활용법은 리액트의 라이프사이클과 무관하게 값을 저장하고 갱신하기 위함입니다.

## MutableRef

라이프사이클과 무관하고 갱신이 리렌더링을 시키는 것을 방지할 때 활용하는 방법입니다.

```ts
import { useRef, useEffect } from "react";

export const App = () => {
  const numRef = useRef<string | null>(null);
  useEffect(() => {
    const todoItem = fetch("https://jsonplaceholder.typicode.com/todos/1")
      .then((response) => response.json())
      .then((json) => console.log(json));
    numRef.current.value = todoItem.id;
  }, []);
  return <div>{numRef.current}</div>;
};
```

useRef로 만든 인스턴스의 current에 useEffect 콜백함수 안에 있는 값을 참조시켜서 외부로 가져오는 방법으로 활용하는 것도 가능합니다.

```tsx
import { useState, useRef, useEffect } from "react";

export const MutableRef = () => {
  const [timer, setTimer] = useState(0);
  const interValRef = useRef<number | null>(null);

  const stopTimer = () => {
    if (interValRef.current) window.clearInterval(interValRef.current);
  };

  useEffect(() => {
    interValRef.current = window.setInterval(() => {
      setTimer((timer) => timer + 1);
    }, 1000);
    return () => {
      stopTimer();
    };
  }, []);

  return (
    <div>
      HookTimer - {timer} -{" "}
      <button onClick={() => stopTimer()}>Stop Timer</button>
    </div>
  );
};
```

`MutableRef`는 각각의 적절한 타입을 지정합니다. 이경우는 `number`를 타입으로 지정해줘야 합니다.

이런식으로 `useEffect`로 부터 자유롭게 값을 할 당할 수 있습니다.

```js
function CounterKai() {
  const counter = useRef(0);
  useEffect(() => {
    const timer = setInterval(() => {
      counter.current += 1;
    }, 1000);
    return () => {
      clearInterval(timer);
      alert("<CounterKai/>:", counter.current);
    };
  }, []);
  return (
    <div>
      <p>{counter.current}</p>
    </div>
  );
}
```

감이 잘 안 온다면 인터넷에서 찾은 다른 예시입니다.

[React Hooks useEffect를 쓸 때, useState vs useRef (feat.closure)](https://cereme.dev/frontend/react-hooks-useeffect-useref-feat-closure/)

## Callback Ref

DOM Ref는 DOM을 동작시키고 쓰기(write)작업과 비슷합니다. Callback Ref는 DOM을 읽을 때 활용합니다. 또 useRef hook을 사용하는 것이 아니라 useCallback hook을 활용하기 때문에 useRef를 사용한 경우라고 볼 수 없습니다. 하지만 Ref 개념을 다룰 때는 같이 알아야 하는 것 중 하나입니다.

```js
function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback((node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <>
      <h1 ref={measuredRef}>Hello, world</h1>
      <h2>The above header is {Math.round(height)}px tall</h2>
    </>
  );
}
```

## 결론

- useRef는 DOM을 조작하고 제어할 때 활용하는 DOMRef의 경우가 있습니다.
- 라이프사이클과 무관하게 데이터를 보관하기 위해 MutableRef가 존재합니다.
- useRef를 활용하는 경우가 아니지만 DOM 측정을 위해 활용하는 Callback Ref로 DOM의 변화를 감지할 수 있습니다. DOM을 참조한다는 측면에서 같이 알아 둬야 합니다.

---

[이화랑 블로그 - React useRef의 다양한 활용 방법(mutable object, callback ref와 forwardRef)](https://leehwarang.github.io/2020/11/29/ref.html)

[cereme.dev - React Hooks useEffect를 쓸 때, useState vs useRef (feat.closure)](https://cereme.dev/frontend/react-hooks-useeffect-useref-feat-closure/)

[Codevolution - React TypeScript Tutorial - 16 - useRef Hook](https://www.youtube.com/watch?v=hA4i1RTbZ2A)

[전 리액트 공식문서 - 콜백 ref](https://ko.reactjs.org/docs/refs-and-the-dom.html#callback-refs)

[전 리액트 공식문서 - DOM 노드를 측정하려면 어떻게 해야 합니까?](https://ko.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node)
